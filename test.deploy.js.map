{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///test.deploy.js","webpack:///webpack/bootstrap b1d33f9b351a4b805a66","webpack:///./node_modules/should-type/cjs/should-type.js","webpack:///./node_modules/should-type-adaptors/cjs/should-type-adaptors.js","webpack:///./node_modules/should-util/cjs/should-util.js","webpack:///test.support.js","webpack:///./node_modules/should/index.js","webpack:///./node_modules/should/cjs/should.js","webpack:///./node_modules/buffer/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/ieee754/index.js","webpack:///./node_modules/isarray/index.js","webpack:///./node_modules/should-equal/cjs/should-equal.js","webpack:///./node_modules/should-format/cjs/should-format.js","webpack:///nmde.support.js","webpack:///falzy.support.js","webpack:///truly.support.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","Buffer","Type","type","cls","sub","Error","TypeChecker","checks","getGlobalType","obj","main","getType","types","NUMBER","UNDEFINED","STRING","BOOLEAN","OBJECT","FUNCTION","NULL","ARRAY","REGEXP","DATE","ERROR","ARGUMENTS","SYMBOL","ARRAY_BUFFER","TYPED_ARRAY","DATA_VIEW","MAP","SET","WEAK_SET","WEAK_MAP","PROMISE","BUFFER","HTML_ELEMENT","HTML_ELEMENT_TEXT","DOCUMENT","WINDOW","FILE","FILE_LIST","BLOB","HOST","XHR","SIMD","toString","sep","str","push","join","toTryTypes","_types","add","func","addBeforeFirstMatch","match","getFirstMatch","splice","index","addTypeOf","res","tpeOf","addClass","objCls","typeOf","length","result","Promise","then","Node","nodeName","Boolean","Number","String","Date","checker","keys","forEach","typeName","ObjectIterator","_obj","TypeAdaptorStorage","_typeAdaptors","_iterableTypes","f","context","shouldUtil","isGeneratorFunction","isIterator","value","next","done","t","defaultTypeAdaptorStorage","requireAdaptor","size","getAdaptor","len","isEmpty","has","key","reduce","initialValue","some","every","isIterable","isIterableType","iterator","_interopDefault","ex","__shouldIterator__","_done","_keys","_index","Symbol","adaptor","addType","tp","funcName","tries","toTry","shift","ad","a","addIterableType","objectAdaptor","prop","propertyIsEnumerable","mapAdaptor","entries","setAdaptor","merge","_hasOwnProperty","_propertyIsEnumerable","b","test","assert","nmde","describe","it","equal","hello","entity","should","defaultProto","prevShould","extend","_prevShould","e","isWrapperType","convertPropertyName","format","opts","config","getFormatter","formatProp","formatter","sformat","formatPlainObjectKey","AssertionError","options","message","_message","generateMessage","generatedMessage","captureStackTrace","stackStartFunction","err","stack","out","fn_name","functionName","idx","indexOf","next_line","substring","prependIndent","line","indent","indentLines","text","split","map","LightAssertionError","Assertion","anyOne","negate","params","actual","PromisedAssertion","apply","arguments","fail","expected","operator","ok","expectedException","_throws","shouldThrow","block","formatEqlResult","r","path","showReason","reason","trim","eql","shouldTypeAdaptors","typeAdaptors","Formatter","create","previous","details","constructor","expr","assertion","light","resolve","reject","onlyThis","args","addChain","onCall","alias","from","to","desc","getOwnPropertyDescriptor","desc2","pSlice","Array","slice","notEqual","deepEqual","notDeepEqual","strictEqual","notStrictEqual","throws","concat","doesNotThrow","ifError","assertExtensions","exist","exists","msg","not","chainAssertions","booleanAssertions","is","exactly","numberAssertions","and","NaN","isFinite","start","finish","description","delta","Math","abs","typeAssertions","have","class","be","null","instanceOf","which","Function","iterable","equalityAssertions","addOneOf","method","vals","found","val","fails","showDiff","promiseAssertions","Assertion$$1","fulfilled","Assertion$fulfilled","that","next$onResolve","next$onReject","rejected","next$onError","fulfilledWith","expectedValue","rejectedWith","properties","errorMatched","errorInfo","RegExp","stringAssertions","containAssertions","other","undefined","v","objIterator","otherIterator","nextObj","nextOther","containDeepOrdered","usedKeys","otherItem","item","containDeep","aSlice","propertyAssertions","processPropsArgs","names","arg","isArray","values","ownProperty","propertyWithDescriptor","missingProperties","props","filter","valueCheckNames","wrongValues","missingKeys","verb","allProps","currentProperty","foundProperties","errorAssertions","fn","thrown","throw","bind","matchingAssertions","exec","notMatchedProps","matchedProps","propertyName","proto","prevDescriptor","set","valueOf","descriptor","noConflict","use","global","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","RangeError","Uint8Array","__proto__","encodingOrOffset","allocUnsafe","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","alloc","fill","encoding","checked","string","isEncoding","byteLength","write","fromArrayLike","array","byteOffset","isBuffer","copy","buffer","isnan","data","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","dir","isNaN","arrayIndexOf","lastIndexOf","arr","read","buf","indexSize","readUInt16BE","arrLength","valLength","foundIndex","j","hexWrite","offset","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","min","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","ret","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","replace","INVALID_BASE64_RE","units","Infinity","leadSurrogate","charCodeAt","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","typedArraySupport","foo","subarray","poolSize","_augment","species","allocUnsafeSlow","_isBuffer","compare","x","y","list","pos","swap16","swap32","swap64","equals","inspect","target","thisStart","thisEnd","thisCopy","targetCopy","includes","toJSON","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","code","g","eval","window","placeHoldersCount","b64","tmp","placeHolders","Arr","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","output","extraBytes","parts","len2","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","rt","log","LN2","EqualityFail","typeToString","setBooleanDefault","defaults","EQ","DEFAULT_OPTIONS","_meet","ShortcutError","eq","check","EQUALITY","checkProtoEql","checkSubType","plusZeroAndMinusZeroEqual","collectAllFails","checkStrictEquality","collectFail","pop","check0","typeA","typeB","name1","name2","defaultCheck","comparison","checkPlainObjectsEquality","meet","st","checkPropertyEquality","getPrototypeOf","flags","iteratorA","nextA","iteratorB","keyFound","nextB","looksLikeANumber","keyCompare","aNum","bNum","localeCompare","genKeysFunc","k","sort","seen","keysFunc","getOwnPropertyNames","getKeys","maxLineLength","propSep","isUTCdate","indentation","EOL","vv","pad","filler","isRight","padding","pad0","matches","functionNameRE","constructorName","addSpaces","INDENT","typeAdaptorForEachFormat","filterKey","formatKey","formatValue","keyValueSep","formatLength","pairs","formattedKey","formattedValue","pair","additionalKeys","keyValue","prefix","lbracket","rbracket","brackets","rootValue","getPropertyDescriptor","formatPlainObjectValue","formatPlainObject","formatWrapper1","formatWrapper2","realValue","formatRegExp","formatFunction","formatArray","formatArguments","_formatDate","isUTC","date","time","getTimezoneOffset","absTo","hours","minutes","tzFormat","formatDate","formatError","generateFormatForNumberArray","lengthProp","byteArrayMaxLength","formattedValues","formatMap","formatSet","genSimdVectorFormat","Constructor","extractLane","defaultFormat","alreadySeen","formatterFunctionName","JSON","stringify","outerHTML","nodeValue","documentElement","falzy","truly"],"mappings":"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","file":"test.deploy.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"test\"] = factory();\n\telse\n\t\troot[\"test\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"test\"] = factory();\n\telse\n\t\troot[\"test\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nvar types = {\n  NUMBER: 'number',\n  UNDEFINED: 'undefined',\n  STRING: 'string',\n  BOOLEAN: 'boolean',\n  OBJECT: 'object',\n  FUNCTION: 'function',\n  NULL: 'null',\n  ARRAY: 'array',\n  REGEXP: 'regexp',\n  DATE: 'date',\n  ERROR: 'error',\n  ARGUMENTS: 'arguments',\n  SYMBOL: 'symbol',\n  ARRAY_BUFFER: 'array-buffer',\n  TYPED_ARRAY: 'typed-array',\n  DATA_VIEW: 'data-view',\n  MAP: 'map',\n  SET: 'set',\n  WEAK_SET: 'weak-set',\n  WEAK_MAP: 'weak-map',\n  PROMISE: 'promise',\n\n// node buffer\n  BUFFER: 'buffer',\n\n// dom html element\n  HTML_ELEMENT: 'html-element',\n  HTML_ELEMENT_TEXT: 'html-element-text',\n  DOCUMENT: 'document',\n  WINDOW: 'window',\n  FILE: 'file',\n  FILE_LIST: 'file-list',\n  BLOB: 'blob',\n\n  HOST: 'host',\n\n  XHR: 'xhr',\n\n  // simd\n  SIMD: 'simd'\n};\n\n/*\n * Simple data function to store type information\n * @param {string} type Usually what is returned from typeof\n * @param {string} cls  Sanitized @Class via Object.prototype.toString\n * @param {string} sub  If type and cls the same, and need to specify somehow\n * @private\n * @example\n *\n * //for null\n * new Type('null');\n *\n * //for Date\n * new Type('object', 'date');\n *\n * //for Uint8Array\n *\n * new Type('object', 'typed-array', 'uint8');\n */\nfunction Type(type, cls, sub) {\n  if (!type) {\n    throw new Error('Type class must be initialized at least with `type` information');\n  }\n  this.type = type;\n  this.cls = cls;\n  this.sub = sub;\n}\n\nType.prototype = {\n  toString: function(sep) {\n    sep = sep || ';';\n    var str = [this.type];\n    if (this.cls) {\n      str.push(this.cls);\n    }\n    if (this.sub) {\n      str.push(this.sub);\n    }\n    return str.join(sep);\n  },\n\n  toTryTypes: function() {\n    var _types = [];\n    if (this.sub) {\n      _types.push(new Type(this.type, this.cls, this.sub));\n    }\n    if (this.cls) {\n      _types.push(new Type(this.type, this.cls));\n    }\n    _types.push(new Type(this.type));\n\n    return _types;\n  }\n};\n\nvar toString = Object.prototype.toString;\n\n\n\n/**\n * Function to store type checks\n * @private\n */\nfunction TypeChecker() {\n  this.checks = [];\n}\n\nTypeChecker.prototype = {\n  add: function(func) {\n    this.checks.push(func);\n    return this;\n  },\n\n  addBeforeFirstMatch: function(obj, func) {\n    var match = this.getFirstMatch(obj);\n    if (match) {\n      this.checks.splice(match.index, 0, func);\n    } else {\n      this.add(func);\n    }\n  },\n\n  addTypeOf: function(type, res) {\n    return this.add(function(obj, tpeOf) {\n      if (tpeOf === type) {\n        return new Type(res);\n      }\n    });\n  },\n\n  addClass: function(cls, res, sub) {\n    return this.add(function(obj, tpeOf, objCls) {\n      if (objCls === cls) {\n        return new Type(types.OBJECT, res, sub);\n      }\n    });\n  },\n\n  getFirstMatch: function(obj) {\n    var typeOf = typeof obj;\n    var cls = toString.call(obj);\n\n    for (var i = 0, l = this.checks.length; i < l; i++) {\n      var res = this.checks[i].call(this, obj, typeOf, cls);\n      if (typeof res !== 'undefined') {\n        return { result: res, func: this.checks[i], index: i };\n      }\n    }\n  },\n\n  getType: function(obj) {\n    var match = this.getFirstMatch(obj);\n    return match && match.result;\n  }\n};\n\nvar main = new TypeChecker();\n\n//TODO add iterators\n\nmain\n  .addTypeOf(types.NUMBER, types.NUMBER)\n  .addTypeOf(types.UNDEFINED, types.UNDEFINED)\n  .addTypeOf(types.STRING, types.STRING)\n  .addTypeOf(types.BOOLEAN, types.BOOLEAN)\n  .addTypeOf(types.FUNCTION, types.FUNCTION)\n  .addTypeOf(types.SYMBOL, types.SYMBOL)\n  .add(function(obj) {\n    if (obj === null) {\n      return new Type(types.NULL);\n    }\n  })\n  .addClass('[object String]', types.STRING)\n  .addClass('[object Boolean]', types.BOOLEAN)\n  .addClass('[object Number]', types.NUMBER)\n  .addClass('[object Array]', types.ARRAY)\n  .addClass('[object RegExp]', types.REGEXP)\n  .addClass('[object Error]', types.ERROR)\n  .addClass('[object Date]', types.DATE)\n  .addClass('[object Arguments]', types.ARGUMENTS)\n\n  .addClass('[object ArrayBuffer]', types.ARRAY_BUFFER)\n  .addClass('[object Int8Array]', types.TYPED_ARRAY, 'int8')\n  .addClass('[object Uint8Array]', types.TYPED_ARRAY, 'uint8')\n  .addClass('[object Uint8ClampedArray]', types.TYPED_ARRAY, 'uint8clamped')\n  .addClass('[object Int16Array]', types.TYPED_ARRAY, 'int16')\n  .addClass('[object Uint16Array]', types.TYPED_ARRAY, 'uint16')\n  .addClass('[object Int32Array]', types.TYPED_ARRAY, 'int32')\n  .addClass('[object Uint32Array]', types.TYPED_ARRAY, 'uint32')\n  .addClass('[object Float32Array]', types.TYPED_ARRAY, 'float32')\n  .addClass('[object Float64Array]', types.TYPED_ARRAY, 'float64')\n\n  .addClass('[object Bool16x8]', types.SIMD, 'bool16x8')\n  .addClass('[object Bool32x4]', types.SIMD, 'bool32x4')\n  .addClass('[object Bool8x16]', types.SIMD, 'bool8x16')\n  .addClass('[object Float32x4]', types.SIMD, 'float32x4')\n  .addClass('[object Int16x8]', types.SIMD, 'int16x8')\n  .addClass('[object Int32x4]', types.SIMD, 'int32x4')\n  .addClass('[object Int8x16]', types.SIMD, 'int8x16')\n  .addClass('[object Uint16x8]', types.SIMD, 'uint16x8')\n  .addClass('[object Uint32x4]', types.SIMD, 'uint32x4')\n  .addClass('[object Uint8x16]', types.SIMD, 'uint8x16')\n\n  .addClass('[object DataView]', types.DATA_VIEW)\n  .addClass('[object Map]', types.MAP)\n  .addClass('[object WeakMap]', types.WEAK_MAP)\n  .addClass('[object Set]', types.SET)\n  .addClass('[object WeakSet]', types.WEAK_SET)\n  .addClass('[object Promise]', types.PROMISE)\n  .addClass('[object Blob]', types.BLOB)\n  .addClass('[object File]', types.FILE)\n  .addClass('[object FileList]', types.FILE_LIST)\n  .addClass('[object XMLHttpRequest]', types.XHR)\n  .add(function(obj) {\n    if ((typeof Promise === types.FUNCTION && obj instanceof Promise) ||\n        (typeof obj.then === types.FUNCTION)) {\n          return new Type(types.OBJECT, types.PROMISE);\n        }\n  })\n  .add(function(obj) {\n    if (typeof Buffer !== 'undefined' && obj instanceof Buffer) {// eslint-disable-line no-undef\n      return new Type(types.OBJECT, types.BUFFER);\n    }\n  })\n  .add(function(obj) {\n    if (typeof Node !== 'undefined' && obj instanceof Node) {\n      return new Type(types.OBJECT, types.HTML_ELEMENT, obj.nodeName);\n    }\n  })\n  .add(function(obj) {\n    // probably at the begginging should be enough these checks\n    if (obj.Boolean === Boolean && obj.Number === Number && obj.String === String && obj.Date === Date) {\n      return new Type(types.OBJECT, types.HOST);\n    }\n  })\n  .add(function() {\n    return new Type(types.OBJECT);\n  });\n\n/**\n * Get type information of anything\n *\n * @param  {any} obj Anything that could require type information\n * @return {Type}    type info\n * @private\n */\nfunction getGlobalType(obj) {\n  return main.getType(obj);\n}\n\ngetGlobalType.checker = main;\ngetGlobalType.TypeChecker = TypeChecker;\ngetGlobalType.Type = Type;\n\nObject.keys(types).forEach(function(typeName) {\n  getGlobalType[typeName] = types[typeName];\n});\n\nmodule.exports = getGlobalType;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).Buffer))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar shouldUtil = __webpack_require__(2);\nvar t = _interopDefault(__webpack_require__(0));\n\n// TODO in future add generators instead of forEach and iterator implementation\n\n\nfunction ObjectIterator(obj) {\n  this._obj = obj;\n}\n\nObjectIterator.prototype = {\n  __shouldIterator__: true, // special marker\n\n  next: function() {\n    if (this._done) {\n      throw new Error('Iterator already reached the end');\n    }\n\n    if (!this._keys) {\n      this._keys = Object.keys(this._obj);\n      this._index = 0;\n    }\n\n    var key = this._keys[this._index];\n    this._done = this._index === this._keys.length;\n    this._index += 1;\n\n    return {\n      value: this._done ? void 0: [key, this._obj[key]],\n      done: this._done\n    };\n  }\n};\n\nif (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n  ObjectIterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n}\n\n\nfunction TypeAdaptorStorage() {\n  this._typeAdaptors = [];\n  this._iterableTypes = {};\n}\n\nTypeAdaptorStorage.prototype = {\n  add: function(type, cls, sub, adaptor) {\n    return this.addType(new t.Type(type, cls, sub), adaptor);\n  },\n\n  addType: function(type, adaptor) {\n    this._typeAdaptors[type.toString()] = adaptor;\n  },\n\n  getAdaptor: function(tp, funcName) {\n    var tries = tp.toTryTypes();\n    while (tries.length) {\n      var toTry = tries.shift();\n      var ad = this._typeAdaptors[toTry];\n      if (ad && ad[funcName]) {\n        return ad[funcName];\n      }\n    }\n  },\n\n  requireAdaptor: function(tp, funcName) {\n    var a = this.getAdaptor(tp, funcName);\n    if (!a) {\n      throw new Error('There is no type adaptor `' + funcName + '` for ' + tp.toString());\n    }\n    return a;\n  },\n\n  addIterableType: function(tp) {\n    this._iterableTypes[tp.toString()] = true;\n  },\n\n  isIterableType: function(tp) {\n    return !!this._iterableTypes[tp.toString()];\n  }\n};\n\nvar defaultTypeAdaptorStorage = new TypeAdaptorStorage();\n\nvar objectAdaptor = {\n  forEach: function(obj, f, context) {\n    for (var prop in obj) {\n      if (shouldUtil.hasOwnProperty(obj, prop) && shouldUtil.propertyIsEnumerable(obj, prop)) {\n        if (f.call(context, obj[prop], prop, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n\n  has: function(obj, prop) {\n    return shouldUtil.hasOwnProperty(obj, prop);\n  },\n\n  get: function(obj, prop) {\n    return obj[prop];\n  },\n\n  iterator: function(obj) {\n    return new ObjectIterator(obj);\n  }\n};\n\n// default for objects\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT), objectAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.FUNCTION), objectAdaptor);\n\nvar mapAdaptor = {\n  has: function(obj, key) {\n    return obj.has(key);\n  },\n\n  get: function(obj, key) {\n    return obj.get(key);\n  },\n\n  forEach: function(obj, f, context) {\n    var iter = obj.entries();\n    forEach(iter, function(value) {\n      return f.call(context, value[1], value[0], obj);\n    });\n  },\n\n  size: function(obj) {\n    return obj.size;\n  },\n\n  isEmpty: function(obj) {\n    return obj.size === 0;\n  },\n\n  iterator: function(obj) {\n    return obj.entries();\n  }\n};\n\nvar setAdaptor = shouldUtil.merge({}, mapAdaptor);\nsetAdaptor.get = function(obj, key) {\n  if (obj.has(key)) {\n    return key;\n  }\n};\n\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.MAP), mapAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.SET), setAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_SET), setAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_MAP), mapAdaptor);\n\ndefaultTypeAdaptorStorage.addType(new t.Type(t.STRING), {\n  isEmpty: function(obj) {\n    return obj === '';\n  },\n\n  size: function(obj) {\n    return obj.length;\n  }\n});\n\ndefaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARRAY));\ndefaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARGUMENTS));\n\nfunction forEach(obj, f, context) {\n  if (shouldUtil.isGeneratorFunction(obj)) {\n    return forEach(obj(), f, context);\n  } else if (shouldUtil.isIterator(obj)) {\n    var value = obj.next();\n    while (!value.done) {\n      if (f.call(context, value.value, 'value', obj) === false) {\n        return;\n      }\n      value = obj.next();\n    }\n  } else {\n    var type = t(obj);\n    var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'forEach');\n    func(obj, f, context);\n  }\n}\n\n\nfunction size(obj) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'size');\n  if (func) {\n    return func(obj);\n  } else {\n    var len = 0;\n    forEach(obj, function() {\n      len += 1;\n    });\n    return len;\n  }\n}\n\nfunction isEmpty(obj) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'isEmpty');\n  if (func) {\n    return func(obj);\n  } else {\n    var res = true;\n    forEach(obj, function() {\n      res = false;\n      return false;\n    });\n    return res;\n  }\n}\n\n// return boolean if obj has such 'key'\nfunction has(obj, key) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'has');\n  return func(obj, key);\n}\n\n// return value for given key\nfunction get(obj, key) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'get');\n  return func(obj, key);\n}\n\nfunction reduce(obj, f, initialValue) {\n  var res = initialValue;\n  forEach(obj, function(value, key) {\n    res = f(res, value, key, obj);\n  });\n  return res;\n}\n\nfunction some(obj, f, context) {\n  var res = false;\n  forEach(obj, function(value, key) {\n    if (f.call(context, value, key, obj)) {\n      res = true;\n      return false;\n    }\n  }, context);\n  return res;\n}\n\nfunction every(obj, f, context) {\n  var res = true;\n  forEach(obj, function(value, key) {\n    if (!f.call(context, value, key, obj)) {\n      res = false;\n      return false;\n    }\n  }, context);\n  return res;\n}\n\nfunction isIterable(obj) {\n  return defaultTypeAdaptorStorage.isIterableType(t(obj));\n}\n\nfunction iterator(obj) {\n  return defaultTypeAdaptorStorage.requireAdaptor(t(obj), 'iterator')(obj);\n}\n\nexports.defaultTypeAdaptorStorage = defaultTypeAdaptorStorage;\nexports.forEach = forEach;\nexports.size = size;\nexports.isEmpty = isEmpty;\nexports.has = has;\nexports.get = get;\nexports.reduce = reduce;\nexports.some = some;\nexports.every = every;\nexports.isIterable = isIterable;\nexports.iterator = iterator;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _propertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction hasOwnProperty(obj, key) {\n  return _hasOwnProperty.call(obj, key);\n}\n\nfunction propertyIsEnumerable(obj, key) {\n  return _propertyIsEnumerable.call(obj, key);\n}\n\nfunction merge(a, b) {\n  if (a && b) {\n    for (var key in b) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n}\n\nfunction isIterator(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (obj.__shouldIterator__) {\n    return true;\n  }\n\n  return typeof obj.next === 'function' &&\n    typeof Symbol === 'function' &&\n    typeof Symbol.iterator === 'symbol' &&\n    typeof obj[Symbol.iterator] === 'function' &&\n    obj[Symbol.iterator]() === obj;\n}\n\n//TODO find better way\nfunction isGeneratorFunction(f) {\n  return typeof f === 'function' && /^function\\s*\\*\\s*/.test(f.toString());\n}\n\nexports.hasOwnProperty = hasOwnProperty;\nexports.propertyIsEnumerable = propertyIsEnumerable;\nexports.merge = merge;\nexports.isIterator = isIterator;\nexports.isGeneratorFunction = isGeneratorFunction;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*;\r\n              \t@test-license:\r\n              \t\tThe MIT License (MIT)\r\n              \t\t@mit-license\r\n              \r\n              \t\tCopyright (@c) 2017 Richeve Siodina Bebedor\r\n              \t\t@email: richeve.bebedor@gmail.com\r\n              \r\n              \t\tPermission is hereby granted, free of charge, to any person obtaining a copy\r\n              \t\tof this software and associated documentation files (the \"Software\"), to deal\r\n              \t\tin the Software without restriction, including without limitation the rights\r\n              \t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n              \t\tcopies of the Software, and to permit persons to whom the Software is\r\n              \t\tfurnished to do so, subject to the following conditions:\r\n              \r\n              \t\tThe above copyright notice and this permission notice shall be included in all\r\n              \t\tcopies or substantial portions of the Software.\r\n              \r\n              \t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n              \t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n              \t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n              \t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n              \t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n              \t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n              \t\tSOFTWARE.\r\n              \t@end-test-license\r\n              \r\n              \t@test-configuration:\r\n              \t\t{\r\n              \t\t\t\"package\": \"nmde\",\r\n              \t\t\t\"path\": \"nmde/test.js\",\r\n              \t\t\t\"file\": \"test.js\",\r\n              \t\t\t\"module\": \"test\",\r\n              \t\t\t\"author\": \"Richeve S. Bebedor\",\r\n              \t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\r\n              \t\t\t\"contributors\": [\r\n              \t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\",\r\n              \t\t\t\t\"Vinse Vinalon <vinsevinalon@gmail.com>\"\r\n              \t\t\t],\r\n              \t\t\t\"repository\": \"https://github.com/volkovasystems/nmde.git\"\r\n              \t\t}\r\n              \t@end-test-configuration\r\n              \r\n              \t@test-documentation:\r\n              \r\n              \t@end-test-documentation\r\n              \r\n              \t@include:\r\n              \t\t{\r\n              \t\t\t\"assert\": \"should\",\r\n              \t\t\t\"nmde\": \"nmde\"\r\n              \t\t}\r\n              \t@end-include\r\n              */\n\nvar assert = __webpack_require__(4);\n\n\n\n//: @client:\nvar nmde = __webpack_require__(13);\n//: @end-client\n\n\n\n\n\n\n\n//: @client:\n\ndescribe(\"nmde\", function () {\n\n\n\tdescribe(\"`nmde( { 'name': 'yeah' } )`\", function () {\n\n\t\tit(\"should return 'yeah'\", function () {\n\n\t\t\tassert.equal(nmde({ 'name': 'yeah' }), \"yeah\");\n\n\t\t});\n\n\t});\n\n\n\tdescribe(\"`nmde( function hello( ){ } )`\", function () {\n\n\t\tit(\"should return 'hello'\", function () {\n\n\t\t\tassert.equal(nmde(function hello() {}), \"hello\");\n\n\t\t});\n\n\t});\n\n\n\tdescribe(\"`nmde( Error )`\", function () {\n\n\t\tit(\"should return 'Error'\", function () {\n\n\t\t\tassert.equal(nmde(Error), \"Error\");\n\n\t\t});\n\n\t});\n\n\n\tdescribe(\"`nmde( ) == ''`\", function () {\n\n\t\tit(\"should return true\", function () {\n\n\t\t\tassert.equal(nmde() == \"\", true);\n\n\t\t});\n\n\t});\n\n\n\tdescribe(\"`nmde( 'test' ) == ''`\", function () {\n\n\t\tit(\"should return true\", function () {\n\n\t\t\tassert.equal(nmde(\"test\") == \"\", true);\n\n\t\t});\n\n\t});\n\n\n\tdescribe(\"`nmde( { } ) == ''`\", function () {\n\n\t\tit(\"should return true\", function () {\n\n\t\t\tassert.equal(nmde({}) == \"\", true);\n\n\t\t});\n\n\t});\n\n\n\tdescribe(\"`nmde( ( ) => { } ) == ''`\", function () {\n\n\t\tit(\"should return true\", function () {\n\n\t\t\tassert.equal(nmde(function () {}) == \"\", true);\n\n\t\t});\n\n\t});\n\n\n\tdescribe(\"`nmde( ( entity ) => ( typeof entity == 'string' ) ) == ''`\", function () {\n\t\tit(\"should return true\", function () {\n\t\t\tassert.equal(nmde(function (entity) {return typeof entity == \"string\";}) == \"\", true);\n\t\t});\n\t});\n\n\n});\n\n//: @end-client\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3Quc3VwcG9ydC5qcyJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwibm1kZSIsImRlc2NyaWJlIiwiaXQiLCJlcXVhbCIsImhlbGxvIiwiRXJyb3IiLCJlbnRpdHkiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdURBLElBQU1BLFNBQVNDLFFBQVMsUUFBVCxDQUFmOzs7O0FBSUE7QUFDQSxJQUFNQyxPQUFPRCxRQUFTLG1CQUFULENBQWI7QUFDQTs7Ozs7Ozs7QUFRQTs7QUFFQUUsU0FBVSxNQUFWLEVBQWtCLFlBQU87OztBQUd4QkEsVUFBVSw4QkFBVixFQUEwQyxZQUFPOztBQUVoREMsS0FBSSxzQkFBSixFQUE0QixZQUFPOztBQUVsQ0osVUFBT0ssS0FBUCxDQUFjSCxLQUFNLEVBQUUsUUFBUSxNQUFWLEVBQU4sQ0FBZCxFQUEwQyxNQUExQzs7QUFFQSxHQUpEOztBQU1BLEVBUkQ7OztBQVdBQyxVQUFVLGdDQUFWLEVBQTRDLFlBQU87O0FBRWxEQyxLQUFJLHVCQUFKLEVBQTZCLFlBQU87O0FBRW5DSixVQUFPSyxLQUFQLENBQWNILEtBQU0sU0FBU0ksS0FBVCxHQUFpQixDQUFHLENBQTFCLENBQWQsRUFBNEMsT0FBNUM7O0FBRUEsR0FKRDs7QUFNQSxFQVJEOzs7QUFXQUgsVUFBVSxpQkFBVixFQUE2QixZQUFPOztBQUVuQ0MsS0FBSSx1QkFBSixFQUE2QixZQUFPOztBQUVuQ0osVUFBT0ssS0FBUCxDQUFjSCxLQUFNSyxLQUFOLENBQWQsRUFBNkIsT0FBN0I7O0FBRUEsR0FKRDs7QUFNQSxFQVJEOzs7QUFXQUosVUFBVSxpQkFBVixFQUE2QixZQUFPOztBQUVuQ0MsS0FBSSxvQkFBSixFQUEwQixZQUFPOztBQUVoQ0osVUFBT0ssS0FBUCxDQUFjSCxVQUFXLEVBQXpCLEVBQTZCLElBQTdCOztBQUVBLEdBSkQ7O0FBTUEsRUFSRDs7O0FBV0FDLFVBQVUsd0JBQVYsRUFBb0MsWUFBTzs7QUFFMUNDLEtBQUksb0JBQUosRUFBMEIsWUFBTzs7QUFFaENKLFVBQU9LLEtBQVAsQ0FBY0gsS0FBTSxNQUFOLEtBQWtCLEVBQWhDLEVBQW9DLElBQXBDOztBQUVBLEdBSkQ7O0FBTUEsRUFSRDs7O0FBV0FDLFVBQVUscUJBQVYsRUFBaUMsWUFBTzs7QUFFdkNDLEtBQUksb0JBQUosRUFBMEIsWUFBTzs7QUFFaENKLFVBQU9LLEtBQVAsQ0FBY0gsS0FBTSxFQUFOLEtBQWUsRUFBN0IsRUFBaUMsSUFBakM7O0FBRUEsR0FKRDs7QUFNQSxFQVJEOzs7QUFXQUMsVUFBVSw0QkFBVixFQUF3QyxZQUFPOztBQUU5Q0MsS0FBSSxvQkFBSixFQUEwQixZQUFPOztBQUVoQ0osVUFBT0ssS0FBUCxDQUFjSCxLQUFNLFlBQU8sQ0FBRyxDQUFoQixLQUFzQixFQUFwQyxFQUF3QyxJQUF4Qzs7QUFFQSxHQUpEOztBQU1BLEVBUkQ7OztBQVdBQyxVQUFVLDZEQUFWLEVBQXlFLFlBQU87QUFDL0VDLEtBQUksb0JBQUosRUFBMEIsWUFBTztBQUNoQ0osVUFBT0ssS0FBUCxDQUFjSCxLQUFNLFVBQUVNLE1BQUYsVUFBZ0IsT0FBT0EsTUFBUCxJQUFpQixRQUFqQyxFQUFOLEtBQXVELEVBQXJFLEVBQXlFLElBQXpFO0FBQ0EsR0FGRDtBQUdBLEVBSkQ7OztBQU9BLENBdkZEOztBQXlGQSIsImZpbGUiOiJ0ZXN0LnN1cHBvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qO1xyXG5cdEB0ZXN0LWxpY2Vuc2U6XHJcblx0XHRUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuXHRcdEBtaXQtbGljZW5zZVxyXG5cclxuXHRcdENvcHlyaWdodCAoQGMpIDIwMTcgUmljaGV2ZSBTaW9kaW5hIEJlYmVkb3JcclxuXHRcdEBlbWFpbDogcmljaGV2ZS5iZWJlZG9yQGdtYWlsLmNvbVxyXG5cclxuXHRcdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuXHRcdG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuXHRcdGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuXHRcdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuXHRcdGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG5cdFx0ZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblx0XHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuXHRcdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG5cdFx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG5cdFx0SU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcblx0XHRGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuXHRcdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuXHRcdExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcblx0XHRPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG5cdFx0U09GVFdBUkUuXHJcblx0QGVuZC10ZXN0LWxpY2Vuc2VcclxuXHJcblx0QHRlc3QtY29uZmlndXJhdGlvbjpcclxuXHRcdHtcclxuXHRcdFx0XCJwYWNrYWdlXCI6IFwibm1kZVwiLFxyXG5cdFx0XHRcInBhdGhcIjogXCJubWRlL3Rlc3QuanNcIixcclxuXHRcdFx0XCJmaWxlXCI6IFwidGVzdC5qc1wiLFxyXG5cdFx0XHRcIm1vZHVsZVwiOiBcInRlc3RcIixcclxuXHRcdFx0XCJhdXRob3JcIjogXCJSaWNoZXZlIFMuIEJlYmVkb3JcIixcclxuXHRcdFx0XCJlTWFpbFwiOiBcInJpY2hldmUuYmViZWRvckBnbWFpbC5jb21cIixcclxuXHRcdFx0XCJjb250cmlidXRvcnNcIjogW1xyXG5cdFx0XHRcdFwiSm9obiBMZW5vbiBNYWdoYW5veSA8am9obmxlbm9ubWFnaGFub3lAZ21haWwuY29tPlwiLFxyXG5cdFx0XHRcdFwiVmluc2UgVmluYWxvbiA8dmluc2V2aW5hbG9uQGdtYWlsLmNvbT5cIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInJlcG9zaXRvcnlcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdm9sa292YXN5c3RlbXMvbm1kZS5naXRcIlxyXG5cdFx0fVxyXG5cdEBlbmQtdGVzdC1jb25maWd1cmF0aW9uXHJcblxyXG5cdEB0ZXN0LWRvY3VtZW50YXRpb246XHJcblxyXG5cdEBlbmQtdGVzdC1kb2N1bWVudGF0aW9uXHJcblxyXG5cdEBpbmNsdWRlOlxyXG5cdFx0e1xyXG5cdFx0XHRcImFzc2VydFwiOiBcInNob3VsZFwiLFxyXG5cdFx0XHRcIm5tZGVcIjogXCJubWRlXCJcclxuXHRcdH1cclxuXHRAZW5kLWluY2x1ZGVcclxuKi9cclxuXHJcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoIFwic2hvdWxkXCIgKTtcclxuXHJcblxyXG5cclxuLy86IEBjbGllbnQ6XHJcbmNvbnN0IG5tZGUgPSByZXF1aXJlKCBcIi4vbm1kZS5zdXBwb3J0LmpzXCIgKTtcclxuLy86IEBlbmQtY2xpZW50XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLzogQGNsaWVudDpcclxuXHJcbmRlc2NyaWJlKCBcIm5tZGVcIiwgKCApID0+IHtcclxuXHJcblxyXG5cdGRlc2NyaWJlKCBcImBubWRlKCB7ICduYW1lJzogJ3llYWgnIH0gKWBcIiwgKCApID0+IHtcclxuXHJcblx0XHRpdCggXCJzaG91bGQgcmV0dXJuICd5ZWFoJ1wiLCAoICkgPT4ge1xyXG5cclxuXHRcdFx0YXNzZXJ0LmVxdWFsKCBubWRlKCB7ICduYW1lJzogJ3llYWgnIH0gKSwgXCJ5ZWFoXCIgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblxyXG5cdGRlc2NyaWJlKCBcImBubWRlKCBmdW5jdGlvbiBoZWxsbyggKXsgfSApYFwiLCAoICkgPT4ge1xyXG5cclxuXHRcdGl0KCBcInNob3VsZCByZXR1cm4gJ2hlbGxvJ1wiLCAoICkgPT4ge1xyXG5cclxuXHRcdFx0YXNzZXJ0LmVxdWFsKCBubWRlKCBmdW5jdGlvbiBoZWxsbyggKXsgfSApLCBcImhlbGxvXCIgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblxyXG5cdGRlc2NyaWJlKCBcImBubWRlKCBFcnJvciApYFwiLCAoICkgPT4ge1xyXG5cclxuXHRcdGl0KCBcInNob3VsZCByZXR1cm4gJ0Vycm9yJ1wiLCAoICkgPT4ge1xyXG5cclxuXHRcdFx0YXNzZXJ0LmVxdWFsKCBubWRlKCBFcnJvciApLCBcIkVycm9yXCIgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblxyXG5cdGRlc2NyaWJlKCBcImBubWRlKCApID09ICcnYFwiLCAoICkgPT4ge1xyXG5cclxuXHRcdGl0KCBcInNob3VsZCByZXR1cm4gdHJ1ZVwiLCAoICkgPT4ge1xyXG5cclxuXHRcdFx0YXNzZXJ0LmVxdWFsKCBubWRlKCApID09IFwiXCIsIHRydWUgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblxyXG5cdGRlc2NyaWJlKCBcImBubWRlKCAndGVzdCcgKSA9PSAnJ2BcIiwgKCApID0+IHtcclxuXHJcblx0XHRpdCggXCJzaG91bGQgcmV0dXJuIHRydWVcIiwgKCApID0+IHtcclxuXHJcblx0XHRcdGFzc2VydC5lcXVhbCggbm1kZSggXCJ0ZXN0XCIgKSA9PSBcIlwiLCB0cnVlICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cclxuXHRkZXNjcmliZSggXCJgbm1kZSggeyB9ICkgPT0gJydgXCIsICggKSA9PiB7XHJcblxyXG5cdFx0aXQoIFwic2hvdWxkIHJldHVybiB0cnVlXCIsICggKSA9PiB7XHJcblxyXG5cdFx0XHRhc3NlcnQuZXF1YWwoIG5tZGUoIHsgfSApID09IFwiXCIsIHRydWUgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblxyXG5cdGRlc2NyaWJlKCBcImBubWRlKCAoICkgPT4geyB9ICkgPT0gJydgXCIsICggKSA9PiB7XHJcblxyXG5cdFx0aXQoIFwic2hvdWxkIHJldHVybiB0cnVlXCIsICggKSA9PiB7XHJcblxyXG5cdFx0XHRhc3NlcnQuZXF1YWwoIG5tZGUoICggKSA9PiB7IH0gKSA9PSBcIlwiLCB0cnVlICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cclxuXHRkZXNjcmliZSggXCJgbm1kZSggKCBlbnRpdHkgKSA9PiAoIHR5cGVvZiBlbnRpdHkgPT0gJ3N0cmluZycgKSApID09ICcnYFwiLCAoICkgPT4ge1xyXG5cdFx0aXQoIFwic2hvdWxkIHJldHVybiB0cnVlXCIsICggKSA9PiB7XHJcblx0XHRcdGFzc2VydC5lcXVhbCggbm1kZSggKCBlbnRpdHkgKSA9PiAoIHR5cGVvZiBlbnRpdHkgPT0gXCJzdHJpbmdcIiApICkgPT0gXCJcIiwgdHJ1ZSApXHJcblx0XHR9ICk7XHJcblx0fSApO1xyXG5cclxuXHJcbn0gKTtcclxuXHJcbi8vOiBAZW5kLWNsaWVudFxyXG5cclxuXHJcbiJdfQ==\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar should = __webpack_require__(5);\n\nvar defaultProto = Object.prototype;\nvar defaultProperty = 'should';\n\n//Expose api via `Object#should`.\ntry {\n  var prevShould = should.extend(defaultProperty, defaultProto);\n  should._prevShould = prevShould;\n} catch(e) {\n  //ignore errors\n}\n\nmodule.exports = should;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar getType = _interopDefault(__webpack_require__(0));\nvar eql = _interopDefault(__webpack_require__(11));\nvar sformat = _interopDefault(__webpack_require__(12));\nvar shouldTypeAdaptors = __webpack_require__(1);\nvar shouldUtil = __webpack_require__(2);\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\nfunction isWrapperType(obj) {\n  return obj instanceof Number ||\n    obj instanceof String ||\n    obj instanceof Boolean;\n}\n\n// XXX make it more strict: numbers, strings, symbols - and nothing else\nfunction convertPropertyName(name) {\n  return (typeof name === 'symbol') ? name : String(name);\n}\n\nvar functionName = sformat.functionName;\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar config = {\n  typeAdaptors: shouldTypeAdaptors.defaultTypeAdaptorStorage,\n\n  getFormatter: function(opts) {\n    return new sformat.Formatter(opts || config);\n  }\n};\n\nfunction format(value, opts) {\n  return config.getFormatter(opts).format(value);\n}\n\nfunction formatProp(value) {\n  var formatter = config.getFormatter();\n  return sformat.formatPlainObjectKey.call(formatter, value);\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n/**\n * should AssertionError\n * @param {Object} options\n * @constructor\n * @memberOf should\n * @static\n */\nfunction AssertionError(options) {\n  shouldUtil.merge(this, options);\n\n  if (!options.message) {\n    Object.defineProperty(this, 'message', {\n        get: function() {\n          if (!this._message) {\n            this._message = this.generateMessage();\n            this.generatedMessage = true;\n          }\n          return this._message;\n        },\n        configurable: true,\n        enumerable: false\n      }\n    );\n  }\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      if (this.stackStartFunction) {\n        // try to strip useless frames\n        var fn_name = functionName(this.stackStartFunction);\n        var idx = out.indexOf('\\n' + fn_name);\n        if (idx >= 0) {\n          // once we have located the function frame\n          // we need to strip out everything before it (and its line)\n          var next_line = out.indexOf('\\n', idx + 1);\n          out = out.substring(next_line + 1);\n        }\n      }\n\n      this.stack = out;\n    }\n  }\n}\n\n\nvar indent = '    ';\nfunction prependIndent(line) {\n  return indent + line;\n}\n\nfunction indentLines(text) {\n  return text.split('\\n').map(prependIndent).join('\\n');\n}\n\n\n// assert.AssertionError instanceof Error\nAssertionError.prototype = Object.create(Error.prototype, {\n  name: {\n    value: 'AssertionError'\n  },\n\n  generateMessage: {\n    value: function() {\n      if (!this.operator && this.previous) {\n        return this.previous.message;\n      }\n      var actual = format(this.actual);\n      var expected = 'expected' in this ? ' ' + format(this.expected) : '';\n      var details = 'details' in this && this.details ? ' (' + this.details + ')' : '';\n\n      var previous = this.previous ? '\\n' + indentLines(this.previous.message) : '';\n\n      return 'expected ' + actual + (this.negate ? ' not ' : ' ') + this.operator + expected + details + previous;\n    }\n  }\n});\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\n// a bit hacky way how to get error to do not have stack\nfunction LightAssertionError(options) {\n  shouldUtil.merge(this, options);\n\n  if (!options.message) {\n    Object.defineProperty(this, 'message', {\n      get: function() {\n        if (!this._message) {\n          this._message = this.generateMessage();\n          this.generatedMessage = true;\n        }\n        return this._message;\n      }\n    });\n  }\n}\n\nLightAssertionError.prototype = {\n  generateMessage: AssertionError.prototype.generateMessage\n};\n\n\n/**\n * should Assertion\n * @param {*} obj Given object for assertion\n * @constructor\n * @memberOf should\n * @static\n */\nfunction Assertion(obj) {\n  this.obj = obj;\n\n  this.anyOne = false;\n  this.negate = false;\n\n  this.params = {actual: obj};\n}\n\nAssertion.prototype = {\n  constructor: Assertion,\n\n  /**\n   * Base method for assertions.\n   *\n   * Before calling this method need to fill Assertion#params object. This method usually called from other assertion methods.\n   * `Assertion#params` can contain such properties:\n   * * `operator` - required string containing description of this assertion\n   * * `obj` - optional replacement for this.obj, it usefull if you prepare more clear object then given\n   * * `message` - if this property filled with string any others will be ignored and this one used as assertion message\n   * * `expected` - any object used when you need to assert relation between given object and expected. Like given == expected (== is a relation)\n   * * `details` - additional string with details to generated message\n   *\n   * @memberOf Assertion\n   * @category assertion\n   * @param {*} expr Any expression that will be used as a condition for asserting.\n   * @example\n   *\n   * var a = new should.Assertion(42);\n   *\n   * a.params = {\n   *  operator: 'to be magic number',\n   * }\n   *\n   * a.assert(false);\n   * //throws AssertionError: expected 42 to be magic number\n   */\n  assert: function(expr) {\n    if (expr) {\n      return this;\n    }\n\n    var params = this.params;\n\n    if ('obj' in params && !('actual' in params)) {\n      params.actual = params.obj;\n    } else if (!('obj' in params) && !('actual' in params)) {\n      params.actual = this.obj;\n    }\n\n    params.stackStartFunction = params.stackStartFunction || this.assert;\n    params.negate = this.negate;\n\n    params.assertion = this;\n\n    if (this.light) {\n      throw new LightAssertionError(params);\n    } else {\n      throw new AssertionError(params);\n    }\n  },\n\n  /**\n   * Shortcut for `Assertion#assert(false)`.\n   *\n   * @memberOf Assertion\n   * @category assertion\n   * @example\n   *\n   * var a = new should.Assertion(42);\n   *\n   * a.params = {\n   *  operator: 'to be magic number',\n   * }\n   *\n   * a.fail();\n   * //throws AssertionError: expected 42 to be magic number\n   */\n  fail: function() {\n    return this.assert(false);\n  }\n};\n\n\n\n/**\n * Assertion used to delegate calls of Assertion methods inside of Promise.\n * It has almost all methods of Assertion.prototype\n *\n * @param {Promise} obj\n */\nfunction PromisedAssertion(/* obj */) {\n  Assertion.apply(this, arguments);\n}\n\n/**\n * Make PromisedAssertion to look like promise. Delegate resolve and reject to given promise.\n *\n * @private\n * @returns {Promise}\n */\nPromisedAssertion.prototype.then = function(resolve, reject) {\n  return this.obj.then(resolve, reject);\n};\n\n/**\n * Way to extend Assertion function. It uses some logic\n * to define only positive assertions and itself rule with negative assertion.\n *\n * All actions happen in subcontext and this method take care about negation.\n * Potentially we can add some more modifiers that does not depends from state of assertion.\n *\n * @memberOf Assertion\n * @static\n * @param {String} name Name of assertion. It will be used for defining method or getter on Assertion.prototype\n * @param {Function} func Function that will be called on executing assertion\n * @example\n *\n * Assertion.add('asset', function() {\n *      this.params = { operator: 'to be asset' }\n *\n *      this.obj.should.have.property('id').which.is.a.Number()\n *      this.obj.should.have.property('path')\n * })\n */\nAssertion.add = function(name, func) {\n  Object.defineProperty(Assertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    value: function() {\n      var context = new Assertion(this.obj, this, name);\n      context.anyOne = this.anyOne;\n      context.onlyThis = this.onlyThis;\n      // hack\n      context.light = true;\n\n      try {\n        func.apply(context, arguments);\n      } catch (e) {\n        // check for fail\n        if (e instanceof AssertionError || e instanceof LightAssertionError) {\n          // negative fail\n          if (this.negate) {\n            this.obj = context.obj;\n            this.negate = false;\n            return this;\n          }\n\n          if (context !== e.assertion) {\n            context.params.previous = e;\n          }\n\n          // positive fail\n          context.negate = false;\n          // hack\n          context.light = false;\n          context.fail();\n        }\n        // throw if it is another exception\n        throw e;\n      }\n\n      // negative pass\n      if (this.negate) {\n        context.negate = true; // because .fail will set negate\n        context.params.details = 'false negative fail';\n        // hack\n        context.light = false;\n        context.fail();\n      }\n\n      // positive pass\n      if (!this.params.operator) {\n        this.params = context.params; // shortcut\n      }\n      this.obj = context.obj;\n      this.negate = false;\n      return this;\n    }\n  });\n\n  Object.defineProperty(PromisedAssertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    value: function() {\n      var args = arguments;\n      this.obj = this.obj.then(function(a) {\n        return a[name].apply(a, args);\n      });\n\n      return this;\n    }\n  });\n};\n\n/**\n * Add chaining getter to Assertion like .a, .which etc\n *\n * @memberOf Assertion\n * @static\n * @param  {string} name   name of getter\n * @param  {function} [onCall] optional function to call\n */\nAssertion.addChain = function(name, onCall) {\n  onCall = onCall || function() {};\n  Object.defineProperty(Assertion.prototype, name, {\n    get: function() {\n      onCall.call(this);\n      return this;\n    },\n    enumerable: true\n  });\n\n  Object.defineProperty(PromisedAssertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      this.obj = this.obj.then(function(a) {\n        return a[name];\n      });\n\n      return this;\n    }\n  });\n};\n\n/**\n * Create alias for some `Assertion` property\n *\n * @memberOf Assertion\n * @static\n * @param {String} from Name of to map\n * @param {String} to Name of alias\n * @example\n *\n * Assertion.alias('true', 'True')\n */\nAssertion.alias = function(from, to) {\n  var desc = Object.getOwnPropertyDescriptor(Assertion.prototype, from);\n  if (!desc) {\n    throw new Error('Alias ' + from + ' -> ' + to + ' could not be created as ' + from + ' not defined');\n  }\n  Object.defineProperty(Assertion.prototype, to, desc);\n\n  var desc2 = Object.getOwnPropertyDescriptor(PromisedAssertion.prototype, from);\n  if (desc2) {\n    Object.defineProperty(PromisedAssertion.prototype, to, desc2);\n  }\n};\n/**\n * Negation modifier. Current assertion chain become negated. Each call invert negation on current assertion.\n *\n * @name not\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain('not', function() {\n  this.negate = !this.negate;\n});\n\n/**\n * Any modifier - it affect on execution of sequenced assertion to do not `check all`, but `check any of`.\n *\n * @name any\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain('any', function() {\n  this.anyOne = true;\n});\n\n\n/**\n * Only modifier - currently used with .keys to check if object contains only exactly this .keys\n *\n * @name only\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain('only', function() {\n  this.onlyThis = true;\n});\n\n// implement assert interface using already written peaces of should.js\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// when used in node, this will actually load the util module we depend on\n// versus loading the builtin util module as happens otherwise\n// this is a bug in node module loading as far as I am concerned\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = ok;\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n/**\n * Node.js standard [`assert.fail`](http://nodejs.org/api/assert.html#assert_assert_fail_actual_expected_message_operator).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual Actual object\n * @param {*} expected Expected object\n * @param {string} message Message for assertion\n * @param {string} operator Operator text\n */\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  var a = new Assertion(actual);\n  a.params = {\n    operator: operator,\n    expected: expected,\n    message: message,\n    stackStartFunction: stackStartFunction || fail\n  };\n\n  a.fail();\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n/**\n * Node.js standard [`assert.ok`](http://nodejs.org/api/assert.html#assert_assert_value_message_assert_ok_value_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} value\n * @param {string} [message]\n */\nfunction ok(value, message) {\n  if (!value) {\n    fail(value, true, message, '==', assert.ok);\n  }\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\n/**\n * Node.js standard [`assert.equal`](http://nodejs.org/api/assert.html#assert_assert_equal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) {\n    fail(actual, expected, message, '==', assert.equal);\n  }\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notEqual`](http://nodejs.org/api/assert.html#assert_assert_notequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.deepEqual`](http://nodejs.org/api/assert.html#assert_assert_deepequal_actual_expected_message).\n * But uses should.js .eql implementation instead of Node.js own deepEqual.\n *\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (eql(actual, expected).length !== 0) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notDeepEqual`](http://nodejs.org/api/assert.html#assert_assert_notdeepequal_actual_expected_message).\n * But uses should.js .eql implementation instead of Node.js own deepEqual.\n *\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (eql(actual, expected).result) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.strictEqual`](http://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notStrictEqual`](http://nodejs.org/api/assert.html#assert_assert_notstrictequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected == 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ')' : '.') +\n  (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n/**\n * Node.js standard [`assert.throws`](http://nodejs.org/api/assert.html#assert_assert_throws_block_error_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Function} block\n * @param {Function} [error]\n * @param {String} [message]\n */\nassert.throws = function(/*block, error, message*/) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\n/**\n * Node.js standard [`assert.doesNotThrow`](http://nodejs.org/api/assert.html#assert_assert_doesnotthrow_block_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Function} block\n * @param {String} [message]\n */\nassert.doesNotThrow = function(/*block, message*/) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\n/**\n * Node.js standard [`assert.ifError`](http://nodejs.org/api/assert.html#assert_assert_iferror_value).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Error} err\n */\nassert.ifError = function(err) {\n  if (err) {\n    throw err;\n  }\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar assertExtensions = function(should) {\n  var i = should.format;\n\n  /*\n   * Expose assert to should\n   *\n   * This allows you to do things like below\n   * without require()ing the assert module.\n   *\n   *    should.equal(foo.bar, undefined);\n   *\n   */\n  shouldUtil.merge(should, assert);\n\n  /**\n   * Assert _obj_ exists, with optional message.\n   *\n   * @static\n   * @memberOf should\n   * @category assertion assert\n   * @alias should.exists\n   * @param {*} obj\n   * @param {String} [msg]\n   * @example\n   *\n   * should.exist(1);\n   * should.exist(new Date());\n   */\n  should.exist = should.exists = function(obj, msg) {\n    if (null == obj) {\n      throw new AssertionError({\n        message: msg || ('expected ' + i(obj) + ' to exist'), stackStartFunction: should.exist\n      });\n    }\n  };\n\n  should.not = {};\n  /**\n   * Asserts _obj_ does not exist, with optional message.\n   *\n   * @name not.exist\n   * @static\n   * @memberOf should\n   * @category assertion assert\n   * @alias should.not.exists\n   * @param {*} obj\n   * @param {String} [msg]\n   * @example\n   *\n   * should.not.exist(null);\n   * should.not.exist(void 0);\n   */\n  should.not.exist = should.not.exists = function(obj, msg) {\n    if (null != obj) {\n      throw new AssertionError({\n        message: msg || ('expected ' + i(obj) + ' to not exist'), stackStartFunction: should.not.exist\n      });\n    }\n  };\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar chainAssertions = function(should, Assertion) {\n  /**\n   * Simple chaining to improve readability. Does nothing.\n   *\n   * @memberOf Assertion\n   * @name be\n   * @property {should.Assertion} be\n   * @alias Assertion#an\n   * @alias Assertion#of\n   * @alias Assertion#a\n   * @alias Assertion#and\n   * @alias Assertion#been\n   * @alias Assertion#have\n   * @alias Assertion#has\n   * @alias Assertion#with\n   * @alias Assertion#is\n   * @alias Assertion#which\n   * @alias Assertion#the\n   * @alias Assertion#it\n   * @category assertion chaining\n   */\n  ['an', 'of', 'a', 'and', 'be', 'been', 'has', 'have', 'with', 'is', 'which', 'the', 'it'].forEach(function(name) {\n    Assertion.addChain(name);\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar booleanAssertions = function(should, Assertion) {\n  /**\n   * Assert given object is exactly `true`.\n   *\n   * @name true\n   * @memberOf Assertion\n   * @category assertion bool\n   * @alias Assertion#True\n   * @param {string} [message] Optional message\n   * @example\n   *\n   * (true).should.be.true();\n   * false.should.not.be.true();\n   *\n   * ({ a: 10}).should.not.be.true();\n   */\n  Assertion.add('true', function(message) {\n    this.is.exactly(true, message);\n  });\n\n  Assertion.alias('true', 'True');\n\n  /**\n   * Assert given object is exactly `false`.\n   *\n   * @name false\n   * @memberOf Assertion\n   * @category assertion bool\n   * @alias Assertion#False\n   * @param {string} [message] Optional message\n   * @example\n   *\n   * (true).should.not.be.false();\n   * false.should.be.false();\n   */\n  Assertion.add('false', function(message) {\n    this.is.exactly(false, message);\n  });\n\n  Assertion.alias('false', 'False');\n\n  /**\n   * Assert given object is truthy according javascript type conversions.\n   *\n   * @name ok\n   * @memberOf Assertion\n   * @category assertion bool\n   * @example\n   *\n   * (true).should.be.ok();\n   * ''.should.not.be.ok();\n   * should(null).not.be.ok();\n   * should(void 0).not.be.ok();\n   *\n   * (10).should.be.ok();\n   * (0).should.not.be.ok();\n   */\n  Assertion.add('ok', function() {\n    this.params = { operator: 'to be truthy' };\n\n    this.assert(this.obj);\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar numberAssertions = function(should, Assertion) {\n\n  /**\n   * Assert given object is NaN\n   * @name NaN\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @example\n   *\n   * (10).should.not.be.NaN();\n   * NaN.should.be.NaN();\n   */\n  Assertion.add('NaN', function() {\n    this.params = { operator: 'to be NaN' };\n\n    this.assert(this.obj !== this.obj);\n  });\n\n  /**\n   * Assert given object is not finite (positive or negative)\n   *\n   * @name Infinity\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @example\n   *\n   * (10).should.not.be.Infinity();\n   * NaN.should.not.be.Infinity();\n   */\n  Assertion.add('Infinity', function() {\n    this.params = { operator: 'to be Infinity' };\n\n    this.is.a.Number()\n      .and.not.a.NaN()\n      .and.assert(!isFinite(this.obj));\n  });\n\n  /**\n   * Assert given number between `start` and `finish` or equal one of them.\n   *\n   * @name within\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} start Start number\n   * @param {number} finish Finish number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.within(0, 20);\n   */\n  Assertion.add('within', function(start, finish, description) {\n    this.params = { operator: 'to be within ' + start + '..' + finish, message: description };\n\n    this.assert(this.obj >= start && this.obj <= finish);\n  });\n\n  /**\n   * Assert given number near some other `value` within `delta`\n   *\n   * @name approximately\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} value Center number\n   * @param {number} delta Radius\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (9.99).should.be.approximately(10, 0.1);\n   */\n  Assertion.add('approximately', function(value, delta, description) {\n    this.params = { operator: 'to be approximately ' + value + ' ' + delta, message: description };\n\n    this.assert(Math.abs(this.obj - value) <= delta);\n  });\n\n  /**\n   * Assert given number above `n`.\n   *\n   * @name above\n   * @alias Assertion#greaterThan\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.above(0);\n   */\n  Assertion.add('above', function(n, description) {\n    this.params = { operator: 'to be above ' + n, message: description };\n\n    this.assert(this.obj > n);\n  });\n\n  /**\n   * Assert given number below `n`.\n   *\n   * @name below\n   * @alias Assertion#lessThan\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (0).should.be.below(10);\n   */\n  Assertion.add('below', function(n, description) {\n    this.params = { operator: 'to be below ' + n, message: description };\n\n    this.assert(this.obj < n);\n  });\n\n  Assertion.alias('above', 'greaterThan');\n  Assertion.alias('below', 'lessThan');\n\n  /**\n   * Assert given number above `n`.\n   *\n   * @name aboveOrEqual\n   * @alias Assertion#greaterThanOrEqual\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.aboveOrEqual(0);\n   * (10).should.be.aboveOrEqual(10);\n   */\n  Assertion.add('aboveOrEqual', function(n, description) {\n    this.params = { operator: 'to be above or equal' + n, message: description };\n\n    this.assert(this.obj >= n);\n  });\n\n  /**\n   * Assert given number below `n`.\n   *\n   * @name belowOrEqual\n   * @alias Assertion#lessThanOrEqual\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (0).should.be.belowOrEqual(10);\n   * (0).should.be.belowOrEqual(0);\n   */\n  Assertion.add('belowOrEqual', function(n, description) {\n    this.params = { operator: 'to be below or equal' + n, message: description };\n\n    this.assert(this.obj <= n);\n  });\n\n  Assertion.alias('aboveOrEqual', 'greaterThanOrEqual');\n  Assertion.alias('belowOrEqual', 'lessThanOrEqual');\n\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar typeAssertions = function(should, Assertion) {\n  /**\n   * Assert given object is number\n   * @name Number\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Number', function() {\n    this.params = {operator: 'to be a number'};\n\n    this.have.type('number');\n  });\n\n  /**\n   * Assert given object is arguments\n   * @name arguments\n   * @alias Assertion#Arguments\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('arguments', function() {\n    this.params = {operator: 'to be arguments'};\n\n    this.have.class('Arguments');\n  });\n\n  Assertion.alias('arguments', 'Arguments');\n\n  /**\n   * Assert given object has some type using `typeof`\n   * @name type\n   * @memberOf Assertion\n   * @param {string} type Type name\n   * @param {string} [description] Optional message\n   * @category assertion types\n   */\n  Assertion.add('type', function(type, description) {\n    this.params = {operator: 'to have type ' + type, message: description};\n\n    should(typeof this.obj).be.exactly(type);\n  });\n\n  /**\n   * Assert given object is instance of `constructor`\n   * @name instanceof\n   * @alias Assertion#instanceOf\n   * @memberOf Assertion\n   * @param {Function} constructor Constructor function\n   * @param {string} [description] Optional message\n   * @category assertion types\n   */\n  Assertion.add('instanceof', function(constructor, description) {\n    this.params = {operator: 'to be an instance of ' + functionName(constructor), message: description};\n\n    this.assert(Object(this.obj) instanceof constructor);\n  });\n\n  Assertion.alias('instanceof', 'instanceOf');\n\n  /**\n   * Assert given object is function\n   * @name Function\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Function', function() {\n    this.params = {operator: 'to be a function'};\n\n    this.have.type('function');\n  });\n\n  /**\n   * Assert given object is object\n   * @name Object\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Object', function() {\n    this.params = {operator: 'to be an object'};\n\n    this.is.not.null().and.have.type('object');\n  });\n\n  /**\n   * Assert given object is string\n   * @name String\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('String', function() {\n    this.params = {operator: 'to be a string'};\n\n    this.have.type('string');\n  });\n\n  /**\n   * Assert given object is array\n   * @name Array\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Array', function() {\n    this.params = {operator: 'to be an array'};\n\n    this.have.class('Array');\n  });\n\n  /**\n   * Assert given object is boolean\n   * @name Boolean\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Boolean', function() {\n    this.params = {operator: 'to be a boolean'};\n\n    this.have.type('boolean');\n  });\n\n  /**\n   * Assert given object is error\n   * @name Error\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Error', function() {\n    this.params = {operator: 'to be an error'};\n\n    this.have.instanceOf(Error);\n  });\n\n  /**\n   * Assert given object is a date\n   * @name Date\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Date', function() {\n    this.params = {operator: 'to be a date'};\n\n    this.have.instanceOf(Date);\n  });\n\n  /**\n   * Assert given object is null\n   * @name null\n   * @alias Assertion#Null\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('null', function() {\n    this.params = {operator: 'to be null'};\n\n    this.assert(this.obj === null);\n  });\n\n  Assertion.alias('null', 'Null');\n\n  /**\n   * Assert given object has some internal [[Class]], via Object.prototype.toString call\n   * @name class\n   * @alias Assertion#Class\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('class', function(cls) {\n    this.params = {operator: 'to have [[Class]] ' + cls};\n\n    this.assert(Object.prototype.toString.call(this.obj) === '[object ' + cls + ']');\n  });\n\n  Assertion.alias('class', 'Class');\n\n  /**\n   * Assert given object is undefined\n   * @name undefined\n   * @alias Assertion#Undefined\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('undefined', function() {\n    this.params = {operator: 'to be undefined'};\n\n    this.assert(this.obj === void 0);\n  });\n\n  Assertion.alias('undefined', 'Undefined');\n\n  /**\n   * Assert given object supports es6 iterable protocol (just check\n   * that object has property Symbol.iterator, which is a function)\n   * @name iterable\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add('iterable', function() {\n    this.params = {operator: 'to be iterable'};\n\n    should(this.obj).have.property(Symbol.iterator).which.is.a.Function();\n  });\n\n  /**\n   * Assert given object supports es6 iterator protocol (just check\n   * that object has property next, which is a function)\n   * @name iterator\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add('iterator', function() {\n    this.params = {operator: 'to be iterator'};\n\n    should(this.obj).have.property('next').which.is.a.Function();\n  });\n\n  /**\n   * Assert given object is a generator object\n   * @name generator\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add('generator', function() {\n    this.params = {operator: 'to be generator'};\n\n    should(this.obj).be.iterable\n      .and.iterator\n      .and.it.is.equal(this.obj[Symbol.iterator]());\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction formatEqlResult(r, a, b) {\n  return ((r.path.length > 0 ? 'at ' + r.path.map(formatProp).join(' -> ') : '') +\n  (r.a === a ? '' : ', A has ' + format(r.a)) +\n  (r.b === b ? '' : ' and B has ' + format(r.b)) +\n  (r.showReason ? ' because ' + r.reason : '')).trim();\n}\n\nvar equalityAssertions = function(should, Assertion) {\n\n\n  /**\n   * Deep object equality comparison. For full spec see [`should-equal tests`](https://github.com/shouldjs/equal/blob/master/test.js).\n   *\n   * @name eql\n   * @memberOf Assertion\n   * @category assertion equality\n   * @alias Assertion#deepEqual\n   * @param {*} val Expected value\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.eql(10);\n   * ('10').should.not.be.eql(10);\n   * (-0).should.not.be.eql(+0);\n   *\n   * NaN.should.be.eql(NaN);\n   *\n   * ({ a: 10}).should.be.eql({ a: 10 });\n   * [ 'a' ].should.not.be.eql({ '0': 'a' });\n   */\n  Assertion.add('eql', function(val, description) {\n    this.params = {operator: 'to equal', expected: val, message: description};\n    var obj = this.obj;\n    var fails = eql(this.obj, val, should.config);\n    this.params.details = fails.map(function(fail) {\n      return formatEqlResult(fail, obj, val);\n    }).join(', ');\n\n    this.params.showDiff = eql(getType(obj), getType(val)).length === 0;\n\n    this.assert(fails.length === 0);\n  });\n\n  /**\n   * Exact comparison using ===.\n   *\n   * @name equal\n   * @memberOf Assertion\n   * @category assertion equality\n   * @alias Assertion#exactly\n   * @param {*} val Expected value\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 10.should.be.equal(10);\n   * 'a'.should.be.exactly('a');\n   *\n   * should(null).be.exactly(null);\n   */\n  Assertion.add('equal', function(val, description) {\n    this.params = {operator: 'to be', expected: val, message: description};\n\n    this.params.showDiff = eql(getType(this.obj), getType(val)).length === 0;\n\n    this.assert(val === this.obj);\n  });\n\n  Assertion.alias('equal', 'exactly');\n  Assertion.alias('eql', 'deepEqual');\n\n  function addOneOf(name, message, method) {\n    Assertion.add(name, function(vals) {\n      if (arguments.length !== 1) {\n        vals = Array.prototype.slice.call(arguments);\n      } else {\n        should(vals).be.Array();\n      }\n\n      this.params = {operator: message, expected: vals};\n\n      var obj = this.obj;\n      var found = false;\n\n      shouldTypeAdaptors.forEach(vals, function(val) {\n        try {\n          should(val)[method](obj);\n          found = true;\n          return false;\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            return;//do nothing\n          }\n          throw e;\n        }\n      });\n\n      this.assert(found);\n    });\n  }\n\n  /**\n   * Exact comparison using === to be one of supplied objects.\n   *\n   * @name equalOneOf\n   * @memberOf Assertion\n   * @category assertion equality\n   * @param {Array|*} vals Expected values\n   * @example\n   *\n   * 'ab'.should.be.equalOneOf('a', 10, 'ab');\n   * 'ab'.should.be.equalOneOf(['a', 10, 'ab']);\n   */\n  addOneOf('equalOneOf', 'to be equals one of', 'equal');\n\n  /**\n   * Exact comparison using .eql to be one of supplied objects.\n   *\n   * @name oneOf\n   * @memberOf Assertion\n   * @category assertion equality\n   * @param {Array|*} vals Expected values\n   * @example\n   *\n   * ({a: 10}).should.be.oneOf('a', 10, 'ab', {a: 10});\n   * ({a: 10}).should.be.oneOf(['a', 10, 'ab', {a: 10}]);\n   */\n  addOneOf('oneOf', 'to be one of', 'eql');\n\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar promiseAssertions = function(should, Assertion$$1) {\n  /**\n   * Assert given object is a Promise\n   *\n   * @name Promise\n   * @memberOf Assertion\n   * @category assertion promises\n   * @example\n   *\n   * promise.should.be.Promise()\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.a.Promise()\n   * (10).should.not.be.a.Promise()\n   */\n  Assertion$$1.add('Promise', function() {\n    this.params = {operator: 'to be promise'};\n\n    var obj = this.obj;\n\n    should(obj).have.property('then')\n      .which.is.a.Function();\n  });\n\n  /**\n   * Assert given promise will be fulfilled. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilled\n   * @memberOf Assertion\n   * @returns {Promise}\n   * @category assertion promises\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.fulfilled();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.fulfilled();\n   * });\n   */\n  Assertion$$1.prototype.fulfilled = function Assertion$fulfilled() {\n    this.params = {operator: 'to be fulfilled'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function next$onResolve(value) {\n      if (that.negate) {\n        that.fail();\n      }\n      return value;\n    }, function next$onReject(err) {\n      if (!that.negate) {\n        that.params.operator += ', but it was rejected with ' + should.format(err);\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be rejected. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejected\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.not.be.rejected();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => reject(new Error('boom')))\n   *      .should.be.rejected();\n   * });\n   */\n  Assertion$$1.prototype.rejected = function() {\n    this.params = {operator: 'to be rejected'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (!that.negate) {\n        that.params.operator += ', but it was fulfilled';\n        if (arguments.length != 0) {\n          that.params.operator += ' with ' + should.format(value);\n        }\n        that.fail();\n      }\n      return value;\n    }, function next$onError(err) {\n      if (that.negate) {\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be fulfilled with some expected value (value compared using .eql).\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilledWith\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.fulfilledWith(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => resolve(10))\n   *       .should.be.fulfilledWith(10);\n   * });\n   */\n  Assertion$$1.prototype.fulfilledWith = function(expectedValue) {\n    this.params = {operator: 'to be fulfilled with ' + should.format(expectedValue)};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (that.negate) {\n        that.fail();\n      }\n      should(value).eql(expectedValue);\n      return value;\n    }, function next$onError(err) {\n      if (!that.negate) {\n        that.params.operator += ', but it was rejected with ' + should.format(err);\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be rejected with some sort of error. Arguments is the same for Assertion#throw.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejectedWith\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * function failedPromise() {\n   *   return new Promise(function(resolve, reject) {\n   *     reject(new Error('boom'))\n   *   })\n   * }\n   * failedPromise().should.be.rejectedWith(Error);\n   * failedPromise().should.be.rejectedWith('boom');\n   * failedPromise().should.be.rejectedWith(/boom/);\n   * failedPromise().should.be.rejectedWith(Error, { message: 'boom' });\n   * failedPromise().should.be.rejectedWith({ message: 'boom' });\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return failedPromise().should.be.rejectedWith({ message: 'boom' });\n   * });\n   */\n  Assertion$$1.prototype.rejectedWith = function(message, properties) {\n    this.params = {operator: 'to be rejected'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (!that.negate) {\n        that.fail();\n      }\n      return value;\n    }, function next$onError(err) {\n      if (that.negate) {\n        that.fail();\n      }\n\n      var errorMatched = true;\n      var errorInfo = '';\n\n      if ('string' === typeof message) {\n        errorMatched = message === err.message;\n      } else if (message instanceof RegExp) {\n        errorMatched = message.test(err.message);\n      } else if ('function' === typeof message) {\n        errorMatched = err instanceof message;\n      } else if (message !== null && typeof message === 'object') {\n        try {\n          should(err).match(message);\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            errorInfo = ': ' + e.message;\n            errorMatched = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      if (!errorMatched) {\n        if ( typeof message === 'string' || message instanceof RegExp) {\n          errorInfo = ' with a message matching ' + should.format(message) + \", but got '\" + err.message + \"'\";\n        } else if ('function' === typeof message) {\n          errorInfo = ' of type ' + functionName(message) + ', but got ' + functionName(err.constructor);\n        }\n      } else if ('function' === typeof message && properties) {\n        try {\n          should(err).match(properties);\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            errorInfo = ': ' + e.message;\n            errorMatched = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      that.params.operator += errorInfo;\n\n      that.assert(errorMatched);\n\n      return err;\n    });\n  };\n\n  /**\n   * Assert given object is promise and wrap it in PromisedAssertion, which has all properties of Assertion.\n   * That means you can chain as with usual Assertion.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name finally\n   * @memberOf Assertion\n   * @alias Assertion#eventually\n   * @category assertion promises\n   * @returns {PromisedAssertion} Like Assertion, but .then this.obj in Assertion\n   * @example\n   *\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.eventually.equal(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.finally.equal(10);\n   * });\n   */\n  Object.defineProperty(Assertion$$1.prototype, 'finally', {\n    get: function() {\n      should(this.obj).be.a.Promise();\n\n      var that = this;\n\n      return new PromisedAssertion(this.obj.then(function(obj) {\n        var a = should(obj);\n\n        a.negate = that.negate;\n        a.anyOne = that.anyOne;\n\n        return a;\n      }));\n    }\n  });\n\n  Assertion$$1.alias('finally', 'eventually');\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar stringAssertions = function(should, Assertion) {\n  /**\n   * Assert given string starts with prefix\n   * @name startWith\n   * @memberOf Assertion\n   * @category assertion strings\n   * @param {string} str Prefix\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 'abc'.should.startWith('a');\n   */\n  Assertion.add('startWith', function(str, description) {\n    this.params = { operator: 'to start with ' + should.format(str), message: description };\n\n    this.assert(0 === this.obj.indexOf(str));\n  });\n\n  /**\n   * Assert given string ends with prefix\n   * @name endWith\n   * @memberOf Assertion\n   * @category assertion strings\n   * @param {string} str Prefix\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 'abca'.should.endWith('a');\n   */\n  Assertion.add('endWith', function(str, description) {\n    this.params = { operator: 'to end with ' + should.format(str), message: description };\n\n    this.assert(this.obj.indexOf(str, this.obj.length - str.length) >= 0);\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar containAssertions = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Assert that given object contain something that equal to `other`. It uses `should-equal` for equality checks.\n   * If given object is array it search that one of elements was equal to `other`.\n   * If given object is string it checks if `other` is a substring - expected that `other` is a string.\n   * If given object is Object it checks that `other` is a subobject - expected that `other` is a object.\n   *\n   * @name containEql\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [1, 2, 3].should.containEql(1);\n   * [{ a: 1 }, 'a', 10].should.containEql({ a: 1 });\n   *\n   * 'abc'.should.containEql('b');\n   * 'ab1c'.should.containEql(1);\n   *\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ a: 10 });\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ c: { d: 10 }});\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ b: 10 });\n   * // throws AssertionError: expected { a: 10, c: { d: 10 } } to contain { b: 10 }\n   * //            expected { a: 10, c: { d: 10 } } to have property b\n   */\n  Assertion.add('containEql', function(other) {\n    this.params = { operator: 'to contain ' + i(other) };\n\n    this.is.not.null().and.not.undefined();\n\n    var obj = this.obj;\n\n    if (typeof obj == 'string') {\n      this.assert(obj.indexOf(String(other)) >= 0);\n    } else if (shouldTypeAdaptors.isIterable(obj)) {\n      this.assert(shouldTypeAdaptors.some(obj, function(v) {\n        return eql(v, other).length === 0;\n      }));\n    } else {\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj).have.value(key, value);\n      }, this);\n    }\n  });\n\n  /**\n   * Assert that given object is contain equally structured object on the same depth level.\n   * If given object is an array and `other` is an array it checks that the eql elements is going in the same sequence in given array (recursive)\n   * If given object is an object it checks that the same keys contain deep equal values (recursive)\n   * On other cases it try to check with `.eql`\n   *\n   * @name containDeepOrdered\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeepOrdered([1, 2]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeepOrdered([ 1, [ 2, 3 ]]);\n   *\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({a: 10});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {c: 10}});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {d: [1, 3]}});\n   */\n  Assertion.add('containDeepOrdered', function(other) {\n    this.params = {operator: 'to contain ' + i(other)};\n\n    var obj = this.obj;\n    if (typeof obj == 'string') {// expect other to be string\n      this.is.equal(String(other));\n    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {\n      var objIterator = shouldTypeAdaptors.iterator(obj);\n      var otherIterator = shouldTypeAdaptors.iterator(other);\n\n      var nextObj = objIterator.next();\n      var nextOther = otherIterator.next();\n      while (!nextObj.done && !nextOther.done) {\n        try {\n          should(nextObj.value[1]).containDeepOrdered(nextOther.value[1]);\n          nextOther = otherIterator.next();\n        } catch (e) {\n          if (!(e instanceof should.AssertionError)) {\n            throw e;\n          }\n        }\n        nextObj = objIterator.next();\n      }\n\n      this.assert(nextOther.done);\n    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {//TODO compare types object contains object case\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj[key]).containDeepOrdered(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (shouldTypeAdaptors.isEmpty(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n\n  /**\n   * The same like `Assertion#containDeepOrdered` but all checks on arrays without order.\n   *\n   * @name containDeep\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeep([2, 1]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeep([ 1, [ 3, 1 ]]);\n   */\n  Assertion.add('containDeep', function(other) {\n    this.params = {operator: 'to contain ' + i(other)};\n\n    var obj = this.obj;\n    if (typeof obj == 'string') {// expect other to be string\n      this.is.equal(String(other));\n    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {\n      var usedKeys = {};\n      shouldTypeAdaptors.forEach(other, function(otherItem) {\n        this.assert(shouldTypeAdaptors.some(obj, function(item, index) {\n          if (index in usedKeys) {\n            return false;\n          }\n\n          try {\n            should(item).containDeep(otherItem);\n            usedKeys[index] = true;\n            return true;\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              return false;\n            }\n            throw e;\n          }\n        }));\n      }, this);\n    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {// object contains object case\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj[key]).containDeep(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (shouldTypeAdaptors.isEmpty(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar aSlice = Array.prototype.slice;\n\nvar propertyAssertions = function(should, Assertion) {\n  var i = should.format;\n  /**\n   * Asserts given object has some descriptor. **On success it change given object to be value of property**.\n   *\n   * @name propertyWithDescriptor\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {Object} desc Descriptor like used in Object.defineProperty (not required to add all properties)\n   * @example\n   *\n   * ({ a: 10 }).should.have.propertyWithDescriptor('a', { enumerable: true });\n   */\n  Assertion.add('propertyWithDescriptor', function(name, desc) {\n    this.params = {actual: this.obj, operator: 'to have own property with descriptor ' + i(desc)};\n    var obj = this.obj;\n    this.have.ownProperty(name);\n    should(Object.getOwnPropertyDescriptor(Object(obj), name)).have.properties(desc);\n  });\n\n  function processPropsArgs() {\n    var args = {};\n    if (arguments.length > 1) {\n      args.names = aSlice.call(arguments);\n    } else {\n      var arg = arguments[0];\n      if (typeof arg === 'string') {\n        args.names = [arg];\n      } else if (Array.isArray(arg)) {\n        args.names = arg;\n      } else {\n        args.names = Object.keys(arg);\n        args.values = arg;\n      }\n    }\n    return args;\n  }\n\n  Assertion.add('enumerable', function(name, val) {\n    name = convertPropertyName(name);\n\n    this.params = {\n      operator: \"to have enumerable property \" + formatProp(name) + (arguments.length > 1 ? \" equal to \" + i(val): \"\")\n    };\n\n    var desc = { enumerable: true };\n    if (arguments.length > 1) {\n      desc.value = val;\n    }\n    this.have.propertyWithDescriptor(name, desc);\n  });\n\n  Assertion.add('enumerables', function(/*names*/) {\n    var args = processPropsArgs.apply(null, arguments);\n\n    this.params = {\n      operator: \"to have enumerables \" + args.names.map(formatProp)\n    };\n\n    var obj = this.obj;\n    args.names.forEach(function(name) {\n      should(obj).have.enumerable(name);\n    });\n  });\n\n  /**\n   * Asserts given object has property with optionally value. **On success it change given object to be value of property**.\n   *\n   * @name property\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {*} [val] Optional property value to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.property('a');\n   */\n  Assertion.add('property', function(name, val) {\n    name = convertPropertyName(name);\n    if (arguments.length > 1) {\n      var p = {};\n      p[name] = val;\n      this.have.properties(p);\n    } else {\n      this.have.properties(name);\n    }\n    this.obj = this.obj[name];\n  });\n\n  /**\n   * Asserts given object has properties. On this method affect .any modifier, which allow to check not all properties.\n   *\n   * @name properties\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string|Object} names Names of property\n   * @example\n   *\n   * ({ a: 10 }).should.have.properties('a');\n   * ({ a: 10, b: 20 }).should.have.properties([ 'a' ]);\n   * ({ a: 10, b: 20 }).should.have.properties({ b: 20 });\n   */\n  Assertion.add('properties', function(names) {\n    var values = {};\n    if (arguments.length > 1) {\n      names = aSlice.call(arguments);\n    } else if (!Array.isArray(names)) {\n      if (typeof names == 'string' || typeof names == 'symbol') {\n        names = [names];\n      } else {\n        values = names;\n        names = Object.keys(names);\n      }\n    }\n\n    var obj = Object(this.obj), missingProperties = [];\n\n    //just enumerate properties and check if they all present\n    names.forEach(function(name) {\n      if (!(name in obj)) {\n        missingProperties.push(formatProp(name));\n      }\n    });\n\n    var props = missingProperties;\n    if (props.length === 0) {\n      props = names.map(formatProp);\n    } else if (this.anyOne) {\n      props = names.filter(function(name) {\n        return missingProperties.indexOf(formatProp(name)) < 0;\n      }).map(formatProp);\n    }\n\n    var operator = (props.length === 1 ?\n        'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');\n\n    this.params = {obj: this.obj, operator: operator};\n\n    //check that all properties presented\n    //or if we request one of them that at least one them presented\n    this.assert(missingProperties.length === 0 || (this.anyOne && missingProperties.length != names.length));\n\n    // check if values in object matched expected\n    var valueCheckNames = Object.keys(values);\n    if (valueCheckNames.length) {\n      var wrongValues = [];\n      props = [];\n\n      // now check values, as there we have all properties\n      valueCheckNames.forEach(function(name) {\n        var value = values[name];\n        if (eql(obj[name], value).length !== 0) {\n          wrongValues.push(formatProp(name) + ' of ' + i(value) + ' (got ' + i(obj[name]) + ')');\n        } else {\n          props.push(formatProp(name) + ' of ' + i(value));\n        }\n      });\n\n      if ((wrongValues.length !== 0 && !this.anyOne) || (this.anyOne && props.length === 0)) {\n        props = wrongValues;\n      }\n\n      operator = (props.length === 1 ?\n        'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');\n\n      this.params = {obj: this.obj, operator: operator};\n\n      //if there is no not matched values\n      //or there is at least one matched\n      this.assert(wrongValues.length === 0 || (this.anyOne && wrongValues.length != valueCheckNames.length));\n    }\n  });\n\n  /**\n   * Asserts given object has property `length` with given value `n`\n   *\n   * @name length\n   * @alias Assertion#lengthOf\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {number} n Expected length\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * [1, 2].should.have.length(2);\n   */\n  Assertion.add('length', function(n, description) {\n    this.have.property('length', n, description);\n  });\n\n  Assertion.alias('length', 'lengthOf');\n\n  /**\n   * Asserts given object has own property. **On success it change given object to be value of property**.\n   *\n   * @name ownProperty\n   * @alias Assertion#hasOwnProperty\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * ({ a: 10 }).should.have.ownProperty('a');\n   */\n  Assertion.add('ownProperty', function(name, description) {\n    name = convertPropertyName(name);\n    this.params = {\n      actual: this.obj,\n      operator: 'to have own property ' + formatProp(name),\n      message: description\n    };\n\n    this.assert(shouldUtil.hasOwnProperty(this.obj, name));\n\n    this.obj = this.obj[name];\n  });\n\n  Assertion.alias('ownProperty', 'hasOwnProperty');\n\n  /**\n   * Asserts given object is empty. For strings, arrays and arguments it checks .length property, for objects it checks keys.\n   *\n   * @name empty\n   * @memberOf Assertion\n   * @category assertion property\n   * @example\n   *\n   * ''.should.be.empty();\n   * [].should.be.empty();\n   * ({}).should.be.empty();\n   */\n  Assertion.add('empty', function() {\n    this.params = {operator: 'to be empty'};\n    this.assert(shouldTypeAdaptors.isEmpty(this.obj));\n  }, true);\n\n  /**\n   * Asserts given object has such keys. Compared to `properties`, `keys` does not accept Object as a argument.\n   * When calling via .key current object in assertion changed to value of this key\n   *\n   * @name keys\n   * @alias Assertion#key\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {...*} keys Keys to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.keys('a');\n   * ({ a: 10, b: 20 }).should.have.keys('a', 'b');\n   * (new Map([[1, 2]])).should.have.key(1);\n   *\n   * json.should.have.only.keys('type', 'version')\n   */\n  Assertion.add('keys', function(keys) {\n    keys = aSlice.call(arguments);\n\n    var obj = Object(this.obj);\n\n    // first check if some keys are missing\n    var missingKeys = keys.filter(function(key) {\n      return !shouldTypeAdaptors.has(obj, key);\n    });\n\n    var verb = 'to have ' + (this.onlyThis ? 'only ': '') + (keys.length === 1 ? 'key ' : 'keys ');\n\n    this.params = {operator: verb + keys.join(', ')};\n\n    if (missingKeys.length > 0) {\n      this.params.operator += '\\n\\tmissing keys: ' + missingKeys.join(', ');\n    }\n\n    this.assert(missingKeys.length === 0);\n\n    if (this.onlyThis) {\n      obj.should.have.size(keys.length);\n    }\n  });\n\n\n  Assertion.add('key', function(key) {\n    this.have.keys(key);\n    this.obj = shouldTypeAdaptors.get(this.obj, key);\n  });\n\n  /**\n   * Asserts given object has such value for given key\n   *\n   * @name value\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {*} key Key to check\n   * @param {*} value Value to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.value('a', 10);\n   * (new Map([[1, 2]])).should.have.value(1, 2);\n   */\n  Assertion.add('value', function(key, value) {\n    this.have.key(key).which.is.eql(value);\n  });\n\n  /**\n   * Asserts given object has such size.\n   *\n   * @name size\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {number} s Size to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.size(1);\n   * (new Map([[1, 2]])).should.have.size(1);\n   */\n  Assertion.add('size', function(s) {\n    this.params = { operator: 'to have size ' + s };\n    shouldTypeAdaptors.size(this.obj).should.be.exactly(s);\n  });\n\n  /**\n   * Asserts given object has nested property in depth by path. **On success it change given object to be value of final property**.\n   *\n   * @name propertyByPath\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string} properties Properties path to search\n   * @example\n   *\n   * ({ a: {b: 10}}).should.have.propertyByPath('a', 'b').eql(10);\n   */\n  Assertion.add('propertyByPath', function(properties) {\n    properties = aSlice.call(arguments);\n\n    var allProps = properties.map(formatProp);\n\n    properties = properties.map(convertPropertyName);\n\n    var obj = should(Object(this.obj));\n\n    var foundProperties = [];\n\n    var currentProperty;\n    while (properties.length) {\n      currentProperty = properties.shift();\n      this.params = {operator: 'to have property by path ' + allProps.join(', ') + ' - failed on ' + formatProp(currentProperty)};\n      obj = obj.have.property(currentProperty);\n      foundProperties.push(currentProperty);\n    }\n\n    this.params = {obj: this.obj, operator: 'to have property by path ' + allProps.join(', ')};\n\n    this.obj = obj.obj;\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\nvar errorAssertions = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Assert given function throws error with such message.\n   *\n   * @name throw\n   * @memberOf Assertion\n   * @category assertion errors\n   * @alias Assertion#throwError\n   * @param {string|RegExp|Function|Object|GeneratorFunction|GeneratorObject} [message] Message to match or properties\n   * @param {Object} [properties] Optional properties that will be matched to thrown error\n   * @example\n   *\n   * (function(){ throw new Error('fail') }).should.throw();\n   * (function(){ throw new Error('fail') }).should.throw('fail');\n   * (function(){ throw new Error('fail') }).should.throw(/fail/);\n   *\n   * (function(){ throw new Error('fail') }).should.throw(Error);\n   * var error = new Error();\n   * error.a = 10;\n   * (function(){ throw error; }).should.throw(Error, { a: 10 });\n   * (function(){ throw error; }).should.throw({ a: 10 });\n   * (function*() {\n   *   yield throwError();\n   * }).should.throw();\n   */\n  Assertion.add('throw', function(message, properties) {\n    var fn = this.obj;\n    var err = {};\n    var errorInfo = '';\n    var thrown = false;\n\n    if (shouldUtil.isGeneratorFunction(fn)) {\n      return should(fn()).throw(message, properties);\n    } else if (shouldUtil.isIterator(fn)) {\n      return should(fn.next.bind(fn)).throw(message, properties);\n    }\n\n    this.is.a.Function();\n\n    var errorMatched = true;\n\n    try {\n      fn();\n    } catch (e) {\n      thrown = true;\n      err = e;\n    }\n\n    if (thrown) {\n      if (message) {\n        if ('string' == typeof message) {\n          errorMatched = message == err.message;\n        } else if (message instanceof RegExp) {\n          errorMatched = message.test(err.message);\n        } else if ('function' == typeof message) {\n          errorMatched = err instanceof message;\n        } else if (null != message) {\n          try {\n            should(err).match(message);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n\n        if (!errorMatched) {\n          if ('string' == typeof message || message instanceof RegExp) {\n            errorInfo = \" with a message matching \" + i(message) + \", but got '\" + err.message + \"'\";\n          } else if ('function' == typeof message) {\n            errorInfo = \" of type \" + functionName(message) + \", but got \" + functionName(err.constructor);\n          }\n        } else if ('function' == typeof message && properties) {\n          try {\n            should(err).match(properties);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n      } else {\n        errorInfo = \" (got \" + i(err) + \")\";\n      }\n    }\n\n    this.params = { operator: 'to throw exception' + errorInfo };\n\n    this.assert(thrown);\n    this.assert(errorMatched);\n  });\n\n  Assertion.alias('throw', 'throwError');\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar matchingAssertions = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Asserts if given object match `other` object, using some assumptions:\n   * First object matched if they are equal,\n   * If `other` is a regexp and given object is a string check on matching with regexp\n   * If `other` is a regexp and given object is an array check if all elements matched regexp\n   * If `other` is a regexp and given object is an object check values on matching regexp\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n   * If `other` is an object check if the same keys matched with above rules\n   * All other cases failed.\n   *\n   * Usually it is right idea to add pre type assertions, like `.String()` or `.Object()` to be sure assertions will do what you are expecting.\n   * Object iteration happen by keys (properties with enumerable: true), thus some objects can cause small pain. Typical example is js\n   * Error - it by default has 2 properties `name` and `message`, but they both non-enumerable. In this case make sure you specify checking props (see examples).\n   *\n   * @name match\n   * @memberOf Assertion\n   * @category assertion matching\n   * @param {*} other Object to match\n   * @param {string} [description] Optional message\n   * @example\n   * 'foobar'.should.match(/^foo/);\n   * 'foobar'.should.not.match(/^bar/);\n   *\n   * ({ a: 'foo', c: 'barfoo' }).should.match(/foo$/);\n   *\n   * ['a', 'b', 'c'].should.match(/[a-z]/);\n   *\n   * (5).should.not.match(function(n) {\n   *   return n < 0;\n   * });\n   * (5).should.not.match(function(it) {\n   *    it.should.be.an.Array();\n   * });\n   * ({ a: 10, b: 'abc', c: { d: 10 }, d: 0 }).should\n   * .match({ a: 10, b: /c$/, c: function(it) {\n   *    return it.should.have.property('d', 10);\n   * }});\n   *\n   * [10, 'abc', { d: 10 }, 0].should\n   * .match({ '0': 10, '1': /c$/, '2': function(it) {\n   *    return it.should.have.property('d', 10);\n   * }});\n   *\n   * var myString = 'abc';\n   *\n   * myString.should.be.a.String().and.match(/abc/);\n   *\n   * myString = {};\n   *\n   * myString.should.match(/abc/); //yes this will pass\n   * //better to do\n   * myString.should.be.an.Object().and.not.empty().and.match(/abc/);//fixed\n   *\n   * (new Error('boom')).should.match(/abc/);//passed because no keys\n   * (new Error('boom')).should.not.match({ message: /abc/ });//check specified property\n   */\n  Assertion.add('match', function(other, description) {\n    this.params = {operator: 'to match ' + i(other), message: description};\n\n    if (eql(this.obj, other).length !== 0) {\n      if (other instanceof RegExp) { // something - regex\n\n        if (typeof this.obj == 'string') {\n\n          this.assert(other.exec(this.obj));\n        } else if (null != this.obj && typeof this.obj == 'object') {\n\n          var notMatchedProps = [], matchedProps = [];\n          shouldTypeAdaptors.forEach(this.obj, function(value, name) {\n            if (other.exec(value)) {\n              matchedProps.push(formatProp(name));\n            } else {\n              notMatchedProps.push(formatProp(name) + ' (' + i(value) + ')');\n            }\n          }, this);\n\n          if (notMatchedProps.length) {\n            this.params.operator += '\\n    not matched properties: ' + notMatchedProps.join(', ');\n          }\n          if (matchedProps.length) {\n            this.params.operator += '\\n    matched properties: ' + matchedProps.join(', ');\n          }\n\n          this.assert(notMatchedProps.length === 0);\n        } // should we try to convert to String and exec?\n        else {\n          this.assert(false);\n        }\n      } else if (typeof other == 'function') {\n        var res;\n\n        res = other(this.obj);\n\n        //if we throw exception ok - it is used .should inside\n        if (typeof res == 'boolean') {\n          this.assert(res); // if it is just boolean function assert on it\n        }\n      } else if (other != null && this.obj != null && typeof other == 'object' && typeof this.obj == 'object') { // try to match properties (for Object and Array)\n        notMatchedProps = [];\n        matchedProps = [];\n\n        shouldTypeAdaptors.forEach(other, function(value, key) {\n          try {\n            should(this.obj).have.property(key).which.match(value);\n            matchedProps.push(formatProp(key));\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              notMatchedProps.push(formatProp(key) + ' (' + i(this.obj[key]) + ')');\n            } else {\n              throw e;\n            }\n          }\n        }, this);\n\n        if (notMatchedProps.length) {\n          this.params.operator += '\\n    not matched properties: ' + notMatchedProps.join(', ');\n        }\n        if (matchedProps.length) {\n          this.params.operator += '\\n    matched properties: ' + matchedProps.join(', ');\n        }\n\n        this.assert(notMatchedProps.length === 0);\n      } else {\n        this.assert(false);\n      }\n    }\n  });\n\n  /**\n   * Asserts if given object values or array elements all match `other` object, using some assumptions:\n   * First object matched if they are equal,\n   * If `other` is a regexp - matching with regexp\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n   * All other cases check if this `other` equal to each element\n   *\n   * @name matchEach\n   * @memberOf Assertion\n   * @category assertion matching\n   * @alias Assertion#matchEvery\n   * @param {*} other Object to match\n   * @param {string} [description] Optional message\n   * @example\n   * [ 'a', 'b', 'c'].should.matchEach(/\\w+/);\n   * [ 'a', 'a', 'a'].should.matchEach('a');\n   *\n   * [ 'a', 'a', 'a'].should.matchEach(function(value) { value.should.be.eql('a') });\n   *\n   * { a: 'a', b: 'a', c: 'a' }.should.matchEach(function(value) { value.should.be.eql('a') });\n   */\n  Assertion.add('matchEach', function(other, description) {\n    this.params = {operator: 'to match each ' + i(other), message: description};\n\n    shouldTypeAdaptors.forEach(this.obj, function(value) {\n      should(value).match(other);\n    }, this);\n  });\n\n  /**\n  * Asserts if any of given object values or array elements match `other` object, using some assumptions:\n  * First object matched if they are equal,\n  * If `other` is a regexp - matching with regexp\n  * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n  * All other cases check if this `other` equal to each element\n  *\n  * @name matchAny\n  * @memberOf Assertion\n  * @category assertion matching\n  * @param {*} other Object to match\n  * @alias Assertion#matchSome\n  * @param {string} [description] Optional message\n  * @example\n  * [ 'a', 'b', 'c'].should.matchAny(/\\w+/);\n  * [ 'a', 'b', 'c'].should.matchAny('a');\n  *\n  * [ 'a', 'b', 'c'].should.matchAny(function(value) { value.should.be.eql('a') });\n  *\n  * { a: 'a', b: 'b', c: 'c' }.should.matchAny(function(value) { value.should.be.eql('a') });\n  */\n  Assertion.add('matchAny', function(other, description) {\n    this.params = {operator: 'to match any ' + i(other), message: description};\n\n    this.assert(shouldTypeAdaptors.some(this.obj, function(value) {\n      try {\n        should(value).match(other);\n        return true;\n      } catch (e) {\n        if (e instanceof should.AssertionError) {\n          // Caught an AssertionError, return false to the iterator\n          return false;\n        }\n        throw e;\n      }\n    }));\n  });\n\n  Assertion.alias('matchAny', 'matchSome');\n  Assertion.alias('matchEach', 'matchEvery');\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n/**\n * Our function should\n *\n * @param {*} obj Object to assert\n * @returns {should.Assertion} Returns new Assertion for beginning assertion chain\n * @example\n *\n * var should = require('should');\n * should('abc').be.a.String();\n */\nfunction should(obj) {\n  return (new Assertion(obj));\n}\n\nshould.AssertionError = AssertionError;\nshould.Assertion = Assertion;\n\n// exposing modules dirty way\nshould.modules = {\n  format: sformat,\n  type: getType,\n  equal: eql\n};\nshould.format = format;\n\n/**\n * Object with configuration.\n * It contains such properties:\n * * `checkProtoEql` boolean - Affect if `.eql` will check objects prototypes\n * * `plusZeroAndMinusZeroEqual` boolean - Affect if `.eql` will treat +0 and -0 as equal\n * Also it can contain options for should-format.\n *\n * @type {Object}\n * @memberOf should\n * @static\n * @example\n *\n * var a = { a: 10 }, b = Object.create(null);\n * b.a = 10;\n *\n * a.should.be.eql(b);\n * //not throws\n *\n * should.config.checkProtoEql = true;\n * a.should.be.eql(b);\n * //throws AssertionError: expected { a: 10 } to equal { a: 10 } (because A and B have different prototypes)\n */\nshould.config = config;\n\n/**\n * Allow to extend given prototype with should property using given name. This getter will **unwrap** all standard wrappers like `Number`, `Boolean`, `String`.\n * Using `should(obj)` is the equivalent of using `obj.should` with known issues (like nulls and method calls etc).\n *\n * To add new assertions, need to use Assertion.add method.\n *\n * @param {string} [propertyName] Name of property to add. Default is `'should'`.\n * @param {Object} [proto] Prototype to extend with. Default is `Object.prototype`.\n * @memberOf should\n * @returns {{ name: string, descriptor: Object, proto: Object }} Descriptor enough to return all back\n * @static\n * @example\n *\n * var prev = should.extend('must', Object.prototype);\n *\n * 'abc'.must.startWith('a');\n *\n * var should = should.noConflict(prev);\n * should.not.exist(Object.prototype.must);\n */\nshould.extend = function(propertyName, proto) {\n  propertyName = propertyName || 'should';\n  proto = proto || Object.prototype;\n\n  var prevDescriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n\n  Object.defineProperty(proto, propertyName, {\n    set: function() {\n    },\n    get: function() {\n      return should(isWrapperType(this) ? this.valueOf() : this);\n    },\n    configurable: true\n  });\n\n  return { name: propertyName, descriptor: prevDescriptor, proto: proto };\n};\n\n/**\n * Delete previous extension. If `desc` missing it will remove default extension.\n *\n * @param {{ name: string, descriptor: Object, proto: Object }} [desc] Returned from `should.extend` object\n * @memberOf should\n * @returns {Function} Returns should function\n * @static\n * @example\n *\n * var should = require('should').noConflict();\n *\n * should(Object.prototype).not.have.property('should');\n *\n * var prev = should.extend('must', Object.prototype);\n * 'abc'.must.startWith('a');\n * should.noConflict(prev);\n *\n * should(Object.prototype).not.have.property('must');\n */\nshould.noConflict = function(desc) {\n  desc = desc || should._prevShould;\n\n  if (desc) {\n    delete desc.proto[desc.name];\n\n    if (desc.descriptor) {\n      Object.defineProperty(desc.proto, desc.name, desc.descriptor);\n    }\n  }\n  return should;\n};\n\n/**\n * Simple utility function for a bit more easier should assertion extension\n * @param {Function} f So called plugin function. It should accept 2 arguments: `should` function and `Assertion` constructor\n * @memberOf should\n * @returns {Function} Returns `should` function\n * @static\n * @example\n *\n * should.use(function(should, Assertion) {\n *   Assertion.add('asset', function() {\n *      this.params = { operator: 'to be asset' };\n *\n *      this.obj.should.have.property('id').which.is.a.Number();\n *      this.obj.should.have.property('path');\n *  })\n * })\n */\nshould.use = function(f) {\n  f(should, should.Assertion);\n  return this;\n};\n\nshould\n  .use(assertExtensions)\n  .use(chainAssertions)\n  .use(booleanAssertions)\n  .use(numberAssertions)\n  .use(equalityAssertions)\n  .use(typeAssertions)\n  .use(stringAssertions)\n  .use(propertyAssertions)\n  .use(errorAssertions)\n  .use(matchingAssertions)\n  .use(containAssertions)\n  .use(promiseAssertions);\n\nmodule.exports = should;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(8)\nvar ieee754 = __webpack_require__(9)\nvar isArray = __webpack_require__(10)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar t = _interopDefault(__webpack_require__(0));\n\nfunction format(msg) {\n  var args = arguments;\n  for (var i = 1, l = args.length; i < l; i++) {\n    msg = msg.replace(/%s/, args[i]);\n  }\n  return msg;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction EqualityFail(a, b, reason, path) {\n  this.a = a;\n  this.b = b;\n  this.reason = reason;\n  this.path = path;\n}\n\nfunction typeToString(tp) {\n  return tp.type + (tp.cls ? '(' + tp.cls + (tp.sub ? ' ' + tp.sub : '') + ')' : '');\n}\n\nvar  PLUS_0_AND_MINUS_0 = '+0 is not equal to -0';\nvar  DIFFERENT_TYPES = 'A has type %s and B has type %s';\nvar  EQUALITY = 'A is not equal to B';\nvar  EQUALITY_PROTOTYPE = 'A and B have different prototypes';\nvar  WRAPPED_VALUE = 'A wrapped value is not equal to B wrapped value';\nvar  FUNCTION_SOURCES = 'function A is not equal to B by source code value (via .toString call)';\nvar  MISSING_KEY = '%s has no key %s';\nvar  SET_MAP_MISSING_KEY = 'Set/Map missing key %s';\n\n\nvar DEFAULT_OPTIONS = {\n  checkProtoEql: true,\n  checkSubType: true,\n  plusZeroAndMinusZeroEqual: true,\n  collectAllFails: false\n};\n\nfunction setBooleanDefault(property, obj, opts, defaults) {\n  obj[property] = typeof opts[property] !== 'boolean' ? defaults[property] : opts[property];\n}\n\nvar METHOD_PREFIX = '_check_';\n\nfunction EQ(opts, a, b, path) {\n  opts = opts || {};\n\n  setBooleanDefault('checkProtoEql', this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault('plusZeroAndMinusZeroEqual', this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault('checkSubType', this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault('collectAllFails', this, opts, DEFAULT_OPTIONS);\n\n  this.a = a;\n  this.b = b;\n\n  this._meet = opts._meet || [];\n\n  this.fails = opts.fails || [];\n\n  this.path = path || [];\n}\n\nfunction ShortcutError(fail) {\n  this.name = 'ShortcutError';\n  this.message = 'fail fast';\n  this.fail = fail;\n}\n\nShortcutError.prototype = Object.create(Error.prototype);\n\nEQ.checkStrictEquality = function(a, b) {\n  this.collectFail(a !== b, EQUALITY);\n};\n\nEQ.add = function add(type, cls, sub, f) {\n  var args = Array.prototype.slice.call(arguments);\n  f = args.pop();\n  EQ.prototype[METHOD_PREFIX + args.join('_')] = f;\n};\n\nEQ.prototype = {\n  check: function() {\n    try {\n      this.check0();\n    } catch (e) {\n      if (e instanceof ShortcutError) {\n        return [e.fail];\n      }\n      throw e;\n    }\n    return this.fails;\n  },\n\n  check0: function() {\n    var a = this.a;\n    var b = this.b;\n\n    // equal a and b exit early\n    if (a === b) {\n      // check for +0 !== -0;\n      return this.collectFail(a === 0 && (1 / a !== 1 / b) && !this.plusZeroAndMinusZeroEqual, PLUS_0_AND_MINUS_0);\n    }\n\n    var typeA = t(a);\n    var typeB = t(b);\n\n    // if objects has different types they are not equal\n    if (typeA.type !== typeB.type || typeA.cls !== typeB.cls || typeA.sub !== typeB.sub) {\n      return this.collectFail(true, format(DIFFERENT_TYPES, typeToString(typeA), typeToString(typeB)));\n    }\n\n    // as types the same checks type specific things\n    var name1 = typeA.type, name2 = typeA.type;\n    if (typeA.cls) {\n      name1 += '_' + typeA.cls;\n      name2 += '_' + typeA.cls;\n    }\n    if (typeA.sub) {\n      name2 += '_' + typeA.sub;\n    }\n\n    var f = this[METHOD_PREFIX + name2] || this[METHOD_PREFIX + name1] || this[METHOD_PREFIX + typeA.type] || this.defaultCheck;\n\n    f.call(this, this.a, this.b);\n  },\n\n  collectFail: function(comparison, reason, showReason) {\n    if (comparison) {\n      var res = new EqualityFail(this.a, this.b, reason, this.path);\n      res.showReason = !!showReason;\n\n      this.fails.push(res);\n\n      if (!this.collectAllFails) {\n        throw new ShortcutError(res);\n      }\n    }\n  },\n\n  checkPlainObjectsEquality: function(a, b) {\n    // compare deep objects and arrays\n    // stacks contain references only\n    //\n    var meet = this._meet;\n    var m = this._meet.length;\n    while (m--) {\n      var st = meet[m];\n      if (st[0] === a && st[1] === b) {\n        return;\n      }\n    }\n\n    // add `a` and `b` to the stack of traversed objects\n    meet.push([a, b]);\n\n    // TODO maybe something else like getOwnPropertyNames\n    var key;\n    for (key in b) {\n      if (hasOwnProperty.call(b, key)) {\n        if (hasOwnProperty.call(a, key)) {\n          this.checkPropertyEquality(key);\n        } else {\n          this.collectFail(true, format(MISSING_KEY, 'A', key));\n        }\n      }\n    }\n\n    // ensure both objects have the same number of properties\n    for (key in a) {\n      if (hasOwnProperty.call(a, key)) {\n        this.collectFail(!hasOwnProperty.call(b, key), format(MISSING_KEY, 'B', key));\n      }\n    }\n\n    meet.pop();\n\n    if (this.checkProtoEql) {\n      //TODO should i check prototypes for === or use eq?\n      this.collectFail(Object.getPrototypeOf(a) !== Object.getPrototypeOf(b), EQUALITY_PROTOTYPE, true);\n    }\n\n  },\n\n  checkPropertyEquality: function(propertyName) {\n    var _eq = new EQ(this, this.a[propertyName], this.b[propertyName], this.path.concat([propertyName]));\n    _eq.check0();\n  },\n\n  defaultCheck: EQ.checkStrictEquality\n};\n\n\nEQ.add(t.NUMBER, function(a, b) {\n  this.collectFail((a !== a && b === b) || (b !== b && a === a) || (a !== b && a === a && b === b), EQUALITY);\n});\n\n[t.SYMBOL, t.BOOLEAN, t.STRING].forEach(function(tp) {\n  EQ.add(tp, EQ.checkStrictEquality);\n});\n\nEQ.add(t.FUNCTION, function(a, b) {\n  // functions are compared by their source code\n  this.collectFail(a.toString() !== b.toString(), FUNCTION_SOURCES);\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.REGEXP, function(a, b) {\n  // check regexp flags\n  var flags = ['source', 'global', 'multiline', 'lastIndex', 'ignoreCase', 'sticky', 'unicode'];\n  while (flags.length) {\n    this.checkPropertyEquality(flags.shift());\n  }\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.DATE, function(a, b) {\n  //check by timestamp only (using .valueOf)\n  this.collectFail(+a !== +b, EQUALITY);\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\n[t.NUMBER, t.BOOLEAN, t.STRING].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    //primitive type wrappers\n    this.collectFail(a.valueOf() !== b.valueOf(), WRAPPED_VALUE);\n    // check user properties\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\nEQ.add(t.OBJECT, function(a, b) {\n  this.checkPlainObjectsEquality(a, b);\n});\n\n[t.ARRAY, t.ARGUMENTS, t.TYPED_ARRAY].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    this.checkPropertyEquality('length');\n\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\nEQ.add(t.OBJECT, t.ARRAY_BUFFER, function(a, b) {\n  this.checkPropertyEquality('byteLength');\n\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.ERROR, function(a, b) {\n  this.checkPropertyEquality('name');\n  this.checkPropertyEquality('message');\n\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.BUFFER, function(a) {\n  this.checkPropertyEquality('length');\n\n  var l = a.length;\n  while (l--) {\n    this.checkPropertyEquality(l);\n  }\n\n  //we do not check for user properties because\n  //node Buffer have some strange hidden properties\n});\n\n[t.MAP, t.SET, t.WEAK_MAP, t.WEAK_SET].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    this._meet.push([a, b]);\n\n    var iteratorA = a.entries();\n    for (var nextA = iteratorA.next(); !nextA.done; nextA = iteratorA.next()) {\n\n      var iteratorB = b.entries();\n      var keyFound = false;\n      for (var nextB = iteratorB.next(); !nextB.done; nextB = iteratorB.next()) {\n        // try to check keys first\n        var r = eq(nextA.value[0], nextB.value[0], { collectAllFails: false, _meet: this._meet });\n\n        if (r.length === 0) {\n          keyFound = true;\n\n          // check values also\n          eq(nextA.value[1], nextB.value[1], this);\n        }\n      }\n\n      if (!keyFound) {\n        // no such key at all\n        this.collectFail(true, format(SET_MAP_MISSING_KEY, nextA.value[0]));\n      }\n    }\n\n    this._meet.pop();\n\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\n\nfunction eq(a, b, opts) {\n  return new EQ(opts, a, b).check();\n}\n\neq.EQ = EQ;\n\nmodule.exports = eq;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar t = _interopDefault(__webpack_require__(0));\nvar shouldTypeAdaptors = __webpack_require__(1);\n\nfunction looksLikeANumber(n) {\n  return !!n.match(/\\d+/);\n}\n\nfunction keyCompare(a, b) {\n  var aNum = looksLikeANumber(a);\n  var bNum = looksLikeANumber(b);\n  if (aNum && bNum) {\n    return 1*a - 1*b;\n  } else if (aNum && !bNum) {\n    return -1;\n  } else if (!aNum && bNum) {\n    return 1;\n  } else {\n    return a.localeCompare(b);\n  }\n}\n\nfunction genKeysFunc(f) {\n  return function(value) {\n    var k = f(value);\n    k.sort(keyCompare);\n    return k;\n  };\n}\n\nfunction Formatter(opts) {\n  opts = opts || {};\n\n  this.seen = [];\n\n  var keysFunc;\n  if (typeof opts.keysFunc === 'function') {\n    keysFunc = opts.keysFunc;\n  } else if (opts.keys === false) {\n    keysFunc = Object.getOwnPropertyNames;\n  } else {\n    keysFunc = Object.keys;\n  }\n\n  this.getKeys = genKeysFunc(keysFunc);\n\n  this.maxLineLength = typeof opts.maxLineLength === 'number' ? opts.maxLineLength : 60;\n  this.propSep = opts.propSep || ',';\n\n  this.isUTCdate = !!opts.isUTCdate;\n}\n\n\n\nFormatter.prototype = {\n  constructor: Formatter,\n\n  format: function(value) {\n    var tp = t(value);\n\n    if (this.alreadySeen(value)) {\n      return '[Circular]';\n    }\n\n    var tries = tp.toTryTypes();\n    var f = this.defaultFormat;\n    while (tries.length) {\n      var toTry = tries.shift();\n      var name = Formatter.formatterFunctionName(toTry);\n      if (this[name]) {\n        f = this[name];\n        break;\n      }\n    }\n    return f.call(this, value).trim();\n  },\n\n  defaultFormat: function(obj) {\n    return String(obj);\n  },\n\n  alreadySeen: function(value) {\n    return this.seen.indexOf(value) >= 0;\n  }\n\n};\n\nFormatter.addType = function addType(tp, f) {\n  Formatter.prototype[Formatter.formatterFunctionName(tp)] = f;\n};\n\nFormatter.formatterFunctionName = function formatterFunctionName(tp) {\n  return '_format_' + tp.toString('_');\n};\n\nvar EOL = '\\n';\n\nfunction indent(v, indentation) {\n  return v\n    .split(EOL)\n    .map(function(vv) {\n      return indentation + vv;\n    })\n    .join(EOL);\n}\n\nfunction pad(str, value, filler) {\n  str = String(str);\n  var isRight = false;\n\n  if (value < 0) {\n    isRight = true;\n    value = -value;\n  }\n\n  if (str.length < value) {\n    var padding = new Array(value - str.length + 1).join(filler);\n    return isRight ? str + padding : padding + str;\n  } else {\n    return str;\n  }\n}\n\nfunction pad0(str, value) {\n  return pad(str, value, '0');\n}\n\nvar functionNameRE = /^\\s*function\\s*(\\S*)\\s*\\(/;\n\nfunction functionName(f) {\n  if (f.name) {\n    return f.name;\n  }\n  var matches = f.toString().match(functionNameRE);\n  if (matches === null) {\n    // `functionNameRE` doesn't match arrow functions.\n    return '';\n  }\n  var name = matches[1];\n  return name;\n}\n\nfunction constructorName(obj) {\n  while (obj) {\n    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined &&  typeof descriptor.value === 'function') {\n      var name = functionName(descriptor.value);\n      if (name !== '') {\n        return name;\n      }\n    }\n\n    obj = Object.getPrototypeOf(obj);\n  }\n}\n\nvar INDENT = '  ';\n\nfunction addSpaces(str) {\n  return indent(str, INDENT);\n}\n\nfunction typeAdaptorForEachFormat(obj, opts) {\n  opts = opts || {};\n  var filterKey = opts.filterKey || function() { return true; };\n\n  var formatKey = opts.formatKey || this.format;\n  var formatValue = opts.formatValue || this.format;\n\n  var keyValueSep = typeof opts.keyValueSep !== 'undefined' ? opts.keyValueSep : ': ';\n\n  this.seen.push(obj);\n\n  var formatLength = 0;\n  var pairs = [];\n\n  shouldTypeAdaptors.forEach(obj, function(value, key) {\n    if (!filterKey(key)) {\n      return;\n    }\n\n    var formattedKey = formatKey.call(this, key);\n    var formattedValue = formatValue.call(this, value, key);\n\n    var pair = formattedKey ? (formattedKey + keyValueSep + formattedValue) : formattedValue;\n\n    formatLength += pair.length;\n    pairs.push(pair);\n  }, this);\n\n  this.seen.pop();\n\n  (opts.additionalKeys || []).forEach(function(keyValue) {\n    var pair = keyValue[0] + keyValueSep + this.format(keyValue[1]);\n    formatLength += pair.length;\n    pairs.push(pair);\n  }, this);\n\n  var prefix = opts.prefix || constructorName(obj) || '';\n  if (prefix.length > 0) {\n    prefix += ' ';\n  }\n\n  var lbracket, rbracket;\n  if (Array.isArray(opts.brackets)) {\n    lbracket = opts.brackets[0];\n    rbracket = opts.brackets[1];\n  } else {\n    lbracket = '{';\n    rbracket = '}';\n  }\n\n  var rootValue = opts.value || '';\n\n  if (pairs.length === 0) {\n    return rootValue || (prefix + lbracket + rbracket);\n  }\n\n  if (formatLength <= this.maxLineLength) {\n    return prefix + lbracket + ' ' + (rootValue ? rootValue + ' ' : '') + pairs.join(this.propSep + ' ') + ' ' + rbracket;\n  } else {\n    return prefix + lbracket + '\\n' + (rootValue ? '  ' + rootValue + '\\n' : '') + pairs.map(addSpaces).join(this.propSep + '\\n') + '\\n' + rbracket;\n  }\n}\n\nfunction formatPlainObjectKey(key) {\n  return typeof key === 'string' && key.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*$/) ? key : this.format(key);\n}\n\nfunction getPropertyDescriptor(obj, key) {\n  var desc;\n  try {\n    desc = Object.getOwnPropertyDescriptor(obj, key) || { value: obj[key] };\n  } catch (e) {\n    desc = { value: e };\n  }\n  return desc;\n}\n\nfunction formatPlainObjectValue(obj, key) {\n  var desc = getPropertyDescriptor(obj, key);\n  if (desc.get && desc.set) {\n    return '[Getter/Setter]';\n  }\n  if (desc.get) {\n    return '[Getter]';\n  }\n  if (desc.set) {\n    return '[Setter]';\n  }\n\n  return this.format(desc.value);\n}\n\nfunction formatPlainObject(obj, opts) {\n  opts = opts || {};\n  opts.keyValueSep = ': ';\n  opts.formatKey = opts.formatKey || formatPlainObjectKey;\n  opts.formatValue = opts.formatValue || function(value, key) {\n    return formatPlainObjectValue.call(this, obj, key);\n  };\n  return typeAdaptorForEachFormat.call(this, obj, opts);\n}\n\nfunction formatWrapper1(value) {\n  return formatPlainObject.call(this, value, {\n    additionalKeys: [['[[PrimitiveValue]]', value.valueOf()]]\n  });\n}\n\n\nfunction formatWrapper2(value) {\n  var realValue = value.valueOf();\n\n  return formatPlainObject.call(this, value, {\n    filterKey: function(key) {\n      //skip useless indexed properties\n      return !(key.match(/\\d+/) && parseInt(key, 10) < realValue.length);\n    },\n    additionalKeys: [['[[PrimitiveValue]]', realValue]]\n  });\n}\n\nfunction formatRegExp(value) {\n  return formatPlainObject.call(this, value, {\n    value: String(value)\n  });\n}\n\nfunction formatFunction(value) {\n  return formatPlainObject.call(this, value, {\n    prefix: 'Function',\n    additionalKeys: [['name', functionName(value)]]\n  });\n}\n\nfunction formatArray(value) {\n  return formatPlainObject.call(this, value, {\n    formatKey: function(key) {\n      if (!key.match(/\\d+/)) {\n        return formatPlainObjectKey.call(this, key);\n      }\n    },\n    brackets: ['[', ']']\n  });\n}\n\nfunction formatArguments(value) {\n  return formatPlainObject.call(this, value, {\n    formatKey: function(key) {\n      if (!key.match(/\\d+/)) {\n        return formatPlainObjectKey.call(this, key);\n      }\n    },\n    brackets: ['[', ']'],\n    prefix: 'Arguments'\n  });\n}\n\nfunction _formatDate(value, isUTC) {\n  var prefix = isUTC ? 'UTC' : '';\n\n  var date = value['get' + prefix + 'FullYear']() +\n    '-' +\n    pad0(value['get' + prefix + 'Month']() + 1, 2) +\n    '-' +\n    pad0(value['get' + prefix + 'Date'](), 2);\n\n  var time = pad0(value['get' + prefix + 'Hours'](), 2) +\n    ':' +\n    pad0(value['get' + prefix + 'Minutes'](), 2) +\n    ':' +\n    pad0(value['get' + prefix + 'Seconds'](), 2) +\n    '.' +\n    pad0(value['get' + prefix + 'Milliseconds'](), 3);\n\n  var to = value.getTimezoneOffset();\n  var absTo = Math.abs(to);\n  var hours = Math.floor(absTo / 60);\n  var minutes = absTo - hours * 60;\n  var tzFormat = (to < 0 ? '+' : '-') + pad0(hours, 2) + pad0(minutes, 2);\n\n  return date + ' ' + time + (isUTC ? '' : ' ' + tzFormat);\n}\n\nfunction formatDate(value) {\n  return formatPlainObject.call(this, value, { value: _formatDate(value, this.isUTCdate) });\n}\n\nfunction formatError(value) {\n  return formatPlainObject.call(this, value, {\n    prefix: value.name,\n    additionalKeys: [['message', value.message]]\n  });\n}\n\nfunction generateFormatForNumberArray(lengthProp, name, padding) {\n  return function(value) {\n    var max = this.byteArrayMaxLength || 50;\n    var length = value[lengthProp];\n    var formattedValues = [];\n    var len = 0;\n    for (var i = 0; i < max && i < length; i++) {\n      var b = value[i] || 0;\n      var v = pad0(b.toString(16), padding);\n      len += v.length;\n      formattedValues.push(v);\n    }\n    var prefix = value.constructor.name || name || '';\n    if (prefix) {\n      prefix += ' ';\n    }\n\n    if (formattedValues.length === 0) {\n      return prefix + '[]';\n    }\n\n    if (len <= this.maxLineLength) {\n      return prefix + '[ ' + formattedValues.join(this.propSep + ' ') + ' ' + ']';\n    } else {\n      return prefix + '[\\n' + formattedValues.map(addSpaces).join(this.propSep + '\\n') + '\\n' + ']';\n    }\n  };\n}\n\nfunction formatMap(obj) {\n  return typeAdaptorForEachFormat.call(this, obj, {\n    keyValueSep: ' => '\n  });\n}\n\nfunction formatSet(obj) {\n  return typeAdaptorForEachFormat.call(this, obj, {\n    keyValueSep: '',\n    formatKey: function() { return ''; }\n  });\n}\n\nfunction genSimdVectorFormat(constructorName, length) {\n  return function(value) {\n    var Constructor = value.constructor;\n    var extractLane = Constructor.extractLane;\n\n    var len = 0;\n    var props = [];\n\n    for (var i = 0; i < length; i ++) {\n      var key = this.format(extractLane(value, i));\n      len += key.length;\n      props.push(key);\n    }\n\n    if (len <= this.maxLineLength) {\n      return constructorName + ' [ ' + props.join(this.propSep + ' ') + ' ]';\n    } else {\n      return constructorName + ' [\\n' + props.map(addSpaces).join(this.propSep + '\\n') + '\\n' + ']';\n    }\n  };\n}\n\nfunction defaultFormat(value, opts) {\n  return new Formatter(opts).format(value);\n}\n\ndefaultFormat.Formatter = Formatter;\ndefaultFormat.addSpaces = addSpaces;\ndefaultFormat.pad0 = pad0;\ndefaultFormat.functionName = functionName;\ndefaultFormat.constructorName = constructorName;\ndefaultFormat.formatPlainObjectKey = formatPlainObjectKey;\ndefaultFormat.formatPlainObject = formatPlainObject;\ndefaultFormat.typeAdaptorForEachFormat = typeAdaptorForEachFormat;\n// adding primitive types\nFormatter.addType(new t.Type(t.UNDEFINED), function() {\n  return 'undefined';\n});\nFormatter.addType(new t.Type(t.NULL), function() {\n  return 'null';\n});\nFormatter.addType(new t.Type(t.BOOLEAN), function(value) {\n  return value ? 'true': 'false';\n});\nFormatter.addType(new t.Type(t.SYMBOL), function(value) {\n  return value.toString();\n});\nFormatter.addType(new t.Type(t.NUMBER), function(value) {\n  if (value === 0 && 1 / value < 0) {\n    return '-0';\n  }\n  return String(value);\n});\n\nFormatter.addType(new t.Type(t.STRING), function(value) {\n  return '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n      .replace(/'/g, \"\\\\'\")\n      .replace(/\\\\\"/g, '\"') + '\\'';\n});\n\nFormatter.addType(new t.Type(t.FUNCTION), formatFunction);\n\n// plain object\nFormatter.addType(new t.Type(t.OBJECT), formatPlainObject);\n\n// type wrappers\nFormatter.addType(new t.Type(t.OBJECT, t.NUMBER), formatWrapper1);\nFormatter.addType(new t.Type(t.OBJECT, t.BOOLEAN), formatWrapper1);\nFormatter.addType(new t.Type(t.OBJECT, t.STRING), formatWrapper2);\n\nFormatter.addType(new t.Type(t.OBJECT, t.REGEXP), formatRegExp);\nFormatter.addType(new t.Type(t.OBJECT, t.ARRAY), formatArray);\nFormatter.addType(new t.Type(t.OBJECT, t.ARGUMENTS), formatArguments);\nFormatter.addType(new t.Type(t.OBJECT, t.DATE), formatDate);\nFormatter.addType(new t.Type(t.OBJECT, t.ERROR), formatError);\nFormatter.addType(new t.Type(t.OBJECT, t.SET), formatSet);\nFormatter.addType(new t.Type(t.OBJECT, t.MAP), formatMap);\nFormatter.addType(new t.Type(t.OBJECT, t.WEAK_MAP), formatMap);\nFormatter.addType(new t.Type(t.OBJECT, t.WEAK_SET), formatSet);\n\nFormatter.addType(new t.Type(t.OBJECT, t.BUFFER), generateFormatForNumberArray('length', 'Buffer', 2));\n\nFormatter.addType(new t.Type(t.OBJECT, t.ARRAY_BUFFER), generateFormatForNumberArray('byteLength', 'ArrayBuffer', 2));\n\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int8'), generateFormatForNumberArray('length', 'Int8Array', 2));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint8'), generateFormatForNumberArray('length', 'Uint8Array', 2));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint8clamped'), generateFormatForNumberArray('length', 'Uint8ClampedArray', 2));\n\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int16'), generateFormatForNumberArray('length', 'Int16Array', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint16'), generateFormatForNumberArray('length', 'Uint16Array', 4));\n\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int32'), generateFormatForNumberArray('length', 'Int32Array', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint32'), generateFormatForNumberArray('length', 'Uint32Array', 8));\n\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool16x8'), genSimdVectorFormat('Bool16x8', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool32x4'), genSimdVectorFormat('Bool32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool8x16'), genSimdVectorFormat('Bool8x16', 16));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'float32x4'), genSimdVectorFormat('Float32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int16x8'), genSimdVectorFormat('Int16x8', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int32x4'), genSimdVectorFormat('Int32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int8x16'), genSimdVectorFormat('Int8x16', 16));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint16x8'), genSimdVectorFormat('Uint16x8', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint32x4'), genSimdVectorFormat('Uint32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint8x16'), genSimdVectorFormat('Uint8x16', 16));\n\n\nFormatter.addType(new t.Type(t.OBJECT, t.PROMISE), function() {\n  return '[Promise]';//TODO it could be nice to inspect its state and value\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.XHR), function() {\n  return '[XMLHttpRequest]';//TODO it could be nice to inspect its state\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT), function(value) {\n  return value.outerHTML;\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, '#text'), function(value) {\n  return value.nodeValue;\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, '#document'), function(value) {\n  return value.documentElement.outerHTML;\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HOST), function() {\n  return '[Host]';\n});\n\nmodule.exports = defaultFormat;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*;\r\n              \t@module-license:\r\n              \t\tThe MIT License (MIT)\r\n              \t\t@mit-license\r\n              \r\n              \t\tCopyright (@c) 2017 Richeve Siodina Bebedor\r\n              \t\t@email: richeve.bebedor@gmail.com\r\n              \r\n              \t\tPermission is hereby granted, free of charge, to any person obtaining a copy\r\n              \t\tof this software and associated documentation files (the \"Software\"), to deal\r\n              \t\tin the Software without restriction, including without limitation the rights\r\n              \t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n              \t\tcopies of the Software, and to permit persons to whom the Software is\r\n              \t\tfurnished to do so, subject to the following conditions:\r\n              \r\n              \t\tThe above copyright notice and this permission notice shall be included in all\r\n              \t\tcopies or substantial portions of the Software.\r\n              \r\n              \t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n              \t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n              \t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n              \t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n              \t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n              \t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n              \t\tSOFTWARE.\r\n              \t@end-module-license\r\n              \r\n              \t@module-configuration:\r\n              \t\t{\r\n              \t\t\t\"package\": \"nmde\",\r\n              \t\t\t\"path\": \"nmde/nmde.js\",\r\n              \t\t\t\"file\": \"nmde.js\",\r\n              \t\t\t\"module\": \"nmde\",\r\n              \t\t\t\"author\": \"Richeve S. Bebedor\",\r\n              \t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\r\n              \t\t\t\"contributors\": [\r\n              \t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\",\r\n              \t\t\t\t\"Vinse Vinalon <vinsevinalon@gmail.com>\"\r\n              \t\t\t],\r\n              \t\t\t\"repository\": \"https://github.com/volkovasystems/nmde.git\",\r\n              \t\t\t\"test\": \"nmde-test.js\",\r\n              \t\t\t\"global\": true\r\n              \t\t}\r\n              \t@end-module-configuration\r\n              \r\n              \t@module-documentation:\r\n              \t\tGet string name property of entity.\r\n              \t@end-module-documentation\r\n              \r\n              \t@include:\r\n              \t\t{\r\n              \t\t\t\"falzy\": \"falzy\",\r\n              \t\t\t\"truly\": \"truly\"\r\n              \t\t}\r\n              \t@end-include\r\n              */\n\nvar falzy = __webpack_require__(14);\nvar truly = __webpack_require__(15);\n\nvar EMPTY_NAME = \"\";\n\nvar nmde = function nmde(entity) {\n\t/*;\r\n                                  \t@meta-configuration:\r\n                                  \t\t{\r\n                                  \t\t\t\"entity:required\": [\r\n                                  \t\t\t\t\"function\",\r\n                                  \t\t\t\t\"object\",\r\n                                  \t\t\t\t\"*\"\r\n                                  \t\t\t]\r\n                                  \t\t}\r\n                                  \t@end-meta-configuration\r\n                                  */\n\n\tif (falzy(entity)) {\n\t\treturn EMPTY_NAME;\n\t}\n\n\tif (truly(entity.name) && typeof entity.name == \"string\") {\n\t\treturn entity.name;\n\t}\n\n\treturn EMPTY_NAME;\n};\n\nmodule.exports = nmde;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5tZGUuc3VwcG9ydC5qcyJdLCJuYW1lcyI6WyJmYWx6eSIsInJlcXVpcmUiLCJ0cnVseSIsIkVNUFRZX05BTUUiLCJubWRlIiwiZW50aXR5IiwibmFtZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5REEsSUFBTUEsUUFBUUMsUUFBUyxPQUFULENBQWQ7QUFDQSxJQUFNQyxRQUFRRCxRQUFTLE9BQVQsQ0FBZDs7QUFFQSxJQUFNRSxhQUFhLEVBQW5COztBQUVBLElBQU1DLE9BQU8sU0FBU0EsSUFBVCxDQUFlQyxNQUFmLEVBQXVCO0FBQ25DOzs7Ozs7Ozs7Ozs7QUFZQSxLQUFJTCxNQUFPSyxNQUFQLENBQUosRUFBcUI7QUFDcEIsU0FBT0YsVUFBUDtBQUNBOztBQUVELEtBQUlELE1BQU9HLE9BQU9DLElBQWQsS0FBd0IsT0FBT0QsT0FBT0MsSUFBZCxJQUFzQixRQUFsRCxFQUE0RDtBQUMzRCxTQUFPRCxPQUFPQyxJQUFkO0FBQ0E7O0FBRUQsUUFBT0gsVUFBUDtBQUNBLENBdEJEOztBQXdCQUksT0FBT0MsT0FBUCxHQUFpQkosSUFBakIiLCJmaWxlIjoibm1kZS5zdXBwb3J0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKjtcclxuXHRAbW9kdWxlLWxpY2Vuc2U6XHJcblx0XHRUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuXHRcdEBtaXQtbGljZW5zZVxyXG5cclxuXHRcdENvcHlyaWdodCAoQGMpIDIwMTcgUmljaGV2ZSBTaW9kaW5hIEJlYmVkb3JcclxuXHRcdEBlbWFpbDogcmljaGV2ZS5iZWJlZG9yQGdtYWlsLmNvbVxyXG5cclxuXHRcdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuXHRcdG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuXHRcdGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuXHRcdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuXHRcdGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG5cdFx0ZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblx0XHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcclxuXHRcdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG5cdFx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG5cdFx0SU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcblx0XHRGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuXHRcdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuXHRcdExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcblx0XHRPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxyXG5cdFx0U09GVFdBUkUuXHJcblx0QGVuZC1tb2R1bGUtbGljZW5zZVxyXG5cclxuXHRAbW9kdWxlLWNvbmZpZ3VyYXRpb246XHJcblx0XHR7XHJcblx0XHRcdFwicGFja2FnZVwiOiBcIm5tZGVcIixcclxuXHRcdFx0XCJwYXRoXCI6IFwibm1kZS9ubWRlLmpzXCIsXHJcblx0XHRcdFwiZmlsZVwiOiBcIm5tZGUuanNcIixcclxuXHRcdFx0XCJtb2R1bGVcIjogXCJubWRlXCIsXHJcblx0XHRcdFwiYXV0aG9yXCI6IFwiUmljaGV2ZSBTLiBCZWJlZG9yXCIsXHJcblx0XHRcdFwiZU1haWxcIjogXCJyaWNoZXZlLmJlYmVkb3JAZ21haWwuY29tXCIsXHJcblx0XHRcdFwiY29udHJpYnV0b3JzXCI6IFtcclxuXHRcdFx0XHRcIkpvaG4gTGVub24gTWFnaGFub3kgPGpvaG5sZW5vbm1hZ2hhbm95QGdtYWlsLmNvbT5cIixcclxuXHRcdFx0XHRcIlZpbnNlIFZpbmFsb24gPHZpbnNldmluYWxvbkBnbWFpbC5jb20+XCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJyZXBvc2l0b3J5XCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3ZvbGtvdmFzeXN0ZW1zL25tZGUuZ2l0XCIsXHJcblx0XHRcdFwidGVzdFwiOiBcIm5tZGUtdGVzdC5qc1wiLFxyXG5cdFx0XHRcImdsb2JhbFwiOiB0cnVlXHJcblx0XHR9XHJcblx0QGVuZC1tb2R1bGUtY29uZmlndXJhdGlvblxyXG5cclxuXHRAbW9kdWxlLWRvY3VtZW50YXRpb246XHJcblx0XHRHZXQgc3RyaW5nIG5hbWUgcHJvcGVydHkgb2YgZW50aXR5LlxyXG5cdEBlbmQtbW9kdWxlLWRvY3VtZW50YXRpb25cclxuXHJcblx0QGluY2x1ZGU6XHJcblx0XHR7XHJcblx0XHRcdFwiZmFsenlcIjogXCJmYWx6eVwiLFxyXG5cdFx0XHRcInRydWx5XCI6IFwidHJ1bHlcIlxyXG5cdFx0fVxyXG5cdEBlbmQtaW5jbHVkZVxyXG4qL1xyXG5cclxuY29uc3QgZmFsenkgPSByZXF1aXJlKCBcImZhbHp5XCIgKTtcclxuY29uc3QgdHJ1bHkgPSByZXF1aXJlKCBcInRydWx5XCIgKTtcclxuXHJcbmNvbnN0IEVNUFRZX05BTUUgPSBcIlwiO1xyXG5cclxuY29uc3Qgbm1kZSA9IGZ1bmN0aW9uIG5tZGUoIGVudGl0eSApe1xyXG5cdC8qO1xyXG5cdFx0QG1ldGEtY29uZmlndXJhdGlvbjpcclxuXHRcdFx0e1xyXG5cdFx0XHRcdFwiZW50aXR5OnJlcXVpcmVkXCI6IFtcclxuXHRcdFx0XHRcdFwiZnVuY3Rpb25cIixcclxuXHRcdFx0XHRcdFwib2JqZWN0XCIsXHJcblx0XHRcdFx0XHRcIipcIlxyXG5cdFx0XHRcdF1cclxuXHRcdFx0fVxyXG5cdFx0QGVuZC1tZXRhLWNvbmZpZ3VyYXRpb25cclxuXHQqL1xyXG5cclxuXHRpZiggZmFsenkoIGVudGl0eSApICl7XHJcblx0XHRyZXR1cm4gRU1QVFlfTkFNRTtcclxuXHR9XHJcblxyXG5cdGlmKCB0cnVseSggZW50aXR5Lm5hbWUgKSAmJiB0eXBlb2YgZW50aXR5Lm5hbWUgPT0gXCJzdHJpbmdcIiApe1xyXG5cdFx0cmV0dXJuIGVudGl0eS5uYW1lO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIEVNUFRZX05BTUU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG5tZGU7XHJcbiJdfQ==\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*;\n              \t@module-license:\n              \t\tThe MIT License (MIT)\n              \t\t@mit-license\n              \n              \t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n              \t\t@email: richeve.bebedor@gmail.com\n              \n              \t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n              \t\tof this software and associated documentation files (the \"Software\"), to deal\n              \t\tin the Software without restriction, including without limitation the rights\n              \t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n              \t\tcopies of the Software, and to permit persons to whom the Software is\n              \t\tfurnished to do so, subject to the following conditions:\n              \n              \t\tThe above copyright notice and this permission notice shall be included in all\n              \t\tcopies or substantial portions of the Software.\n              \n              \t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n              \t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n              \t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n              \t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n              \t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n              \t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n              \t\tSOFTWARE.\n              \t@end-module-license\n              \n              \t@module-configuration:\n              \t\t{\n              \t\t\t\"package\": \"falzy\",\n              \t\t\t\"path\": \"falzy/falzy.js\",\n              \t\t\t\"file\": \"falzy.js\",\n              \t\t\t\"module\": \"falzy\",\n              \t\t\t\"author\": \"Richeve S. Bebedor\",\n              \t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n              \t\t\t\"contributors\": [\n              \t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\",\n              \t\t\t\t\"Vinse Vinalon <vinsevinalon@gmail.com>\"\n              \t\t\t],\n              \t\t\t\"repository\": \"https://github.com/volkovasystems/falzy.git\",\n              \t\t\t\"test\": \"falzy-test.js\",\n              \t\t\t\"global\": true\n              \t\t}\n              \t@end-module-configuration\n              \n              \t@module-documentation:\n              \t\tCheck if the value is undefined, null, empty string, and NaN.\n              \t@end-module-documentation\n              \n              \t@note:\n              \t\tThis module should not have a dependency and should remain as simple as possible.\n              \t@end-note\n              */\n\nvar falzy = function falzy(value) {\n\t/*;\n                                   \t@meta-configuration:\n                                   \t\t{\n                                   \t\t\t\"value:required\": \"*\"\n                                   \t\t}\n                                   \t@end-meta-configuration\n                                   */\n\n\tif (typeof value == \"number\") {\n\t\treturn isNaN(value);\n\t}\n\n\treturn typeof value == \"undefined\" || value === null || value === \"\";\n};\n\nmodule.exports = falzy;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZhbHp5LnN1cHBvcnQuanMiXSwibmFtZXMiOlsiZmFsenkiLCJ2YWx1ZSIsImlzTmFOIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQSxJQUFNQSxRQUFRLFNBQVNBLEtBQVQsQ0FBZ0JDLEtBQWhCLEVBQXVCO0FBQ3BDOzs7Ozs7OztBQVFBLEtBQUksT0FBT0EsS0FBUCxJQUFnQixRQUFwQixFQUE4QjtBQUM3QixTQUFPQyxNQUFPRCxLQUFQLENBQVA7QUFDQTs7QUFFRCxRQUFTLE9BQU9BLEtBQVAsSUFBZ0IsV0FBaEIsSUFBK0JBLFVBQVUsSUFBekMsSUFBaURBLFVBQVUsRUFBcEU7QUFDQSxDQWREOztBQWdCQUUsT0FBT0MsT0FBUCxHQUFpQkosS0FBakIiLCJmaWxlIjoiZmFsenkuc3VwcG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKjtcblx0QG1vZHVsZS1saWNlbnNlOlxuXHRcdFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXHRcdEBtaXQtbGljZW5zZVxuXG5cdFx0Q29weXJpZ2h0IChAYykgMjAxNyBSaWNoZXZlIFNpb2RpbmEgQmViZWRvclxuXHRcdEBlbWFpbDogcmljaGV2ZS5iZWJlZG9yQGdtYWlsLmNvbVxuXG5cdFx0UGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuXHRcdG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcblx0XHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG5cdFx0dG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuXHRcdGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuXHRcdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0XHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcblx0XHRjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5cdFx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRcdElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuXHRcdEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuXHRcdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0XHRMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuXHRcdE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5cdFx0U09GVFdBUkUuXG5cdEBlbmQtbW9kdWxlLWxpY2Vuc2VcblxuXHRAbW9kdWxlLWNvbmZpZ3VyYXRpb246XG5cdFx0e1xuXHRcdFx0XCJwYWNrYWdlXCI6IFwiZmFsenlcIixcblx0XHRcdFwicGF0aFwiOiBcImZhbHp5L2ZhbHp5LmpzXCIsXG5cdFx0XHRcImZpbGVcIjogXCJmYWx6eS5qc1wiLFxuXHRcdFx0XCJtb2R1bGVcIjogXCJmYWx6eVwiLFxuXHRcdFx0XCJhdXRob3JcIjogXCJSaWNoZXZlIFMuIEJlYmVkb3JcIixcblx0XHRcdFwiZU1haWxcIjogXCJyaWNoZXZlLmJlYmVkb3JAZ21haWwuY29tXCIsXG5cdFx0XHRcImNvbnRyaWJ1dG9yc1wiOiBbXG5cdFx0XHRcdFwiSm9obiBMZW5vbiBNYWdoYW5veSA8am9obmxlbm9ubWFnaGFub3lAZ21haWwuY29tPlwiLFxuXHRcdFx0XHRcIlZpbnNlIFZpbmFsb24gPHZpbnNldmluYWxvbkBnbWFpbC5jb20+XCJcblx0XHRcdF0sXG5cdFx0XHRcInJlcG9zaXRvcnlcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdm9sa292YXN5c3RlbXMvZmFsenkuZ2l0XCIsXG5cdFx0XHRcInRlc3RcIjogXCJmYWx6eS10ZXN0LmpzXCIsXG5cdFx0XHRcImdsb2JhbFwiOiB0cnVlXG5cdFx0fVxuXHRAZW5kLW1vZHVsZS1jb25maWd1cmF0aW9uXG5cblx0QG1vZHVsZS1kb2N1bWVudGF0aW9uOlxuXHRcdENoZWNrIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG51bGwsIGVtcHR5IHN0cmluZywgYW5kIE5hTi5cblx0QGVuZC1tb2R1bGUtZG9jdW1lbnRhdGlvblxuXG5cdEBub3RlOlxuXHRcdFRoaXMgbW9kdWxlIHNob3VsZCBub3QgaGF2ZSBhIGRlcGVuZGVuY3kgYW5kIHNob3VsZCByZW1haW4gYXMgc2ltcGxlIGFzIHBvc3NpYmxlLlxuXHRAZW5kLW5vdGVcbiovXG5cbmNvbnN0IGZhbHp5ID0gZnVuY3Rpb24gZmFsenkoIHZhbHVlICl7XG5cdC8qO1xuXHRcdEBtZXRhLWNvbmZpZ3VyYXRpb246XG5cdFx0XHR7XG5cdFx0XHRcdFwidmFsdWU6cmVxdWlyZWRcIjogXCIqXCJcblx0XHRcdH1cblx0XHRAZW5kLW1ldGEtY29uZmlndXJhdGlvblxuXHQqL1xuXG5cdGlmKCB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiApe1xuXHRcdHJldHVybiBpc05hTiggdmFsdWUgKTtcblx0fVxuXG5cdHJldHVybiAoIHR5cGVvZiB2YWx1ZSA9PSBcInVuZGVmaW5lZFwiIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiICk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHp5O1xuIl19\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*;\n              \t@module-license:\n              \t\tThe MIT License (MIT)\n              \t\t@mit-license\n              \n              \t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n              \t\t@email: richeve.bebedor@gmail.com\n              \n              \t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n              \t\tof this software and associated documentation files (the \"Software\"), to deal\n              \t\tin the Software without restriction, including without limitation the rights\n              \t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n              \t\tcopies of the Software, and to permit persons to whom the Software is\n              \t\tfurnished to do so, subject to the following conditions:\n              \n              \t\tThe above copyright notice and this permission notice shall be included in all\n              \t\tcopies or substantial portions of the Software.\n              \n              \t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n              \t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n              \t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n              \t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n              \t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n              \t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n              \t\tSOFTWARE.\n              \t@end-module-license\n              \n              \t@module-configuration:\n              \t\t{\n              \t\t\t\"package\": \"truly\",\n              \t\t\t\"path\": \"truly/truly.js\",\n              \t\t\t\"file\": \"truly.js\",\n              \t\t\t\"module\": \"truly\",\n              \t\t\t\"author\": \"Richeve S. Bebedor\",\n              \t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n              \t\t\t\"contributors\": [\n              \t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\",\n              \t\t\t\t\"Vinse Vinalon <vinsevinalon@gmail.com>\"\n              \t\t\t],\n              \t\t\t\"repository\": \"https://github.com/volkovasystems/truly.git\",\n              \t\t\t\"test\": \"truly-test.js\",\n              \t\t\t\"global\": true\n              \t\t}\n              \t@end-module-configuration\n              \n              \t@module-documentation:\n              \t\tCheck if the value is not undefined, null, empty string, NaN and Infinity.\n              \t@end-module-documentation\n              \n              \t@note:\n              \t\tThis module should not have a dependency and should remain as simple as possible.\n              \t@end-note\n              */\n\nvar truly = function truly(value) {\n\t/*;\n                                   \t@meta-configuration:\n                                   \t\t{\n                                   \t\t\t\"value:required\": \"*\"\n                                   \t\t}\n                                   \t@end-meta-configuration\n                                   */\n\n\tif (typeof value == \"number\") {\n\t\treturn !isNaN(value);\n\t}\n\n\treturn typeof value != \"undefined\" && value !== null && value !== \"\";\n};\n\nmodule.exports = truly;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRydWx5LnN1cHBvcnQuanMiXSwibmFtZXMiOlsidHJ1bHkiLCJ2YWx1ZSIsImlzTmFOIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQSxJQUFNQSxRQUFRLFNBQVNBLEtBQVQsQ0FBZ0JDLEtBQWhCLEVBQXVCO0FBQ3BDOzs7Ozs7OztBQVFBLEtBQUksT0FBT0EsS0FBUCxJQUFnQixRQUFwQixFQUE4QjtBQUM3QixTQUFPLENBQUNDLE1BQU9ELEtBQVAsQ0FBUjtBQUNBOztBQUVELFFBQVMsT0FBT0EsS0FBUCxJQUFnQixXQUFoQixJQUErQkEsVUFBVSxJQUF6QyxJQUFpREEsVUFBVSxFQUFwRTtBQUNBLENBZEQ7O0FBZ0JBRSxPQUFPQyxPQUFQLEdBQWlCSixLQUFqQiIsImZpbGUiOiJ0cnVseS5zdXBwb3J0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qO1xuXHRAbW9kdWxlLWxpY2Vuc2U6XG5cdFx0VGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cdFx0QG1pdC1saWNlbnNlXG5cblx0XHRDb3B5cmlnaHQgKEBjKSAyMDE3IFJpY2hldmUgU2lvZGluYSBCZWJlZG9yXG5cdFx0QGVtYWlsOiByaWNoZXZlLmJlYmVkb3JAZ21haWwuY29tXG5cblx0XHRQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5cdFx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuXHRcdGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcblx0XHR0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5cdFx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5cdFx0ZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuXHRcdFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuXHRcdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0XHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5cdFx0SU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5cdFx0RklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdFx0QVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuXHRcdExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5cdFx0T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblx0XHRTT0ZUV0FSRS5cblx0QGVuZC1tb2R1bGUtbGljZW5zZVxuXG5cdEBtb2R1bGUtY29uZmlndXJhdGlvbjpcblx0XHR7XG5cdFx0XHRcInBhY2thZ2VcIjogXCJ0cnVseVwiLFxuXHRcdFx0XCJwYXRoXCI6IFwidHJ1bHkvdHJ1bHkuanNcIixcblx0XHRcdFwiZmlsZVwiOiBcInRydWx5LmpzXCIsXG5cdFx0XHRcIm1vZHVsZVwiOiBcInRydWx5XCIsXG5cdFx0XHRcImF1dGhvclwiOiBcIlJpY2hldmUgUy4gQmViZWRvclwiLFxuXHRcdFx0XCJlTWFpbFwiOiBcInJpY2hldmUuYmViZWRvckBnbWFpbC5jb21cIixcblx0XHRcdFwiY29udHJpYnV0b3JzXCI6IFtcblx0XHRcdFx0XCJKb2huIExlbm9uIE1hZ2hhbm95IDxqb2hubGVub25tYWdoYW5veUBnbWFpbC5jb20+XCIsXG5cdFx0XHRcdFwiVmluc2UgVmluYWxvbiA8dmluc2V2aW5hbG9uQGdtYWlsLmNvbT5cIlxuXHRcdFx0XSxcblx0XHRcdFwicmVwb3NpdG9yeVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS92b2xrb3Zhc3lzdGVtcy90cnVseS5naXRcIixcblx0XHRcdFwidGVzdFwiOiBcInRydWx5LXRlc3QuanNcIixcblx0XHRcdFwiZ2xvYmFsXCI6IHRydWVcblx0XHR9XG5cdEBlbmQtbW9kdWxlLWNvbmZpZ3VyYXRpb25cblxuXHRAbW9kdWxlLWRvY3VtZW50YXRpb246XG5cdFx0Q2hlY2sgaWYgdGhlIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQsIG51bGwsIGVtcHR5IHN0cmluZywgTmFOIGFuZCBJbmZpbml0eS5cblx0QGVuZC1tb2R1bGUtZG9jdW1lbnRhdGlvblxuXG5cdEBub3RlOlxuXHRcdFRoaXMgbW9kdWxlIHNob3VsZCBub3QgaGF2ZSBhIGRlcGVuZGVuY3kgYW5kIHNob3VsZCByZW1haW4gYXMgc2ltcGxlIGFzIHBvc3NpYmxlLlxuXHRAZW5kLW5vdGVcbiovXG5cbmNvbnN0IHRydWx5ID0gZnVuY3Rpb24gdHJ1bHkoIHZhbHVlICl7XG5cdC8qO1xuXHRcdEBtZXRhLWNvbmZpZ3VyYXRpb246XG5cdFx0XHR7XG5cdFx0XHRcdFwidmFsdWU6cmVxdWlyZWRcIjogXCIqXCJcblx0XHRcdH1cblx0XHRAZW5kLW1ldGEtY29uZmlndXJhdGlvblxuXHQqL1xuXG5cdGlmKCB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiApe1xuXHRcdHJldHVybiAhaXNOYU4oIHZhbHVlICk7XG5cdH1cblxuXHRyZXR1cm4gKCB0eXBlb2YgdmFsdWUgIT0gXCJ1bmRlZmluZWRcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gXCJcIiApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cnVseTtcbiJdfQ==\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// test.deploy.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b1d33f9b351a4b805a66","'use strict';\n\nvar types = {\n  NUMBER: 'number',\n  UNDEFINED: 'undefined',\n  STRING: 'string',\n  BOOLEAN: 'boolean',\n  OBJECT: 'object',\n  FUNCTION: 'function',\n  NULL: 'null',\n  ARRAY: 'array',\n  REGEXP: 'regexp',\n  DATE: 'date',\n  ERROR: 'error',\n  ARGUMENTS: 'arguments',\n  SYMBOL: 'symbol',\n  ARRAY_BUFFER: 'array-buffer',\n  TYPED_ARRAY: 'typed-array',\n  DATA_VIEW: 'data-view',\n  MAP: 'map',\n  SET: 'set',\n  WEAK_SET: 'weak-set',\n  WEAK_MAP: 'weak-map',\n  PROMISE: 'promise',\n\n// node buffer\n  BUFFER: 'buffer',\n\n// dom html element\n  HTML_ELEMENT: 'html-element',\n  HTML_ELEMENT_TEXT: 'html-element-text',\n  DOCUMENT: 'document',\n  WINDOW: 'window',\n  FILE: 'file',\n  FILE_LIST: 'file-list',\n  BLOB: 'blob',\n\n  HOST: 'host',\n\n  XHR: 'xhr',\n\n  // simd\n  SIMD: 'simd'\n};\n\n/*\n * Simple data function to store type information\n * @param {string} type Usually what is returned from typeof\n * @param {string} cls  Sanitized @Class via Object.prototype.toString\n * @param {string} sub  If type and cls the same, and need to specify somehow\n * @private\n * @example\n *\n * //for null\n * new Type('null');\n *\n * //for Date\n * new Type('object', 'date');\n *\n * //for Uint8Array\n *\n * new Type('object', 'typed-array', 'uint8');\n */\nfunction Type(type, cls, sub) {\n  if (!type) {\n    throw new Error('Type class must be initialized at least with `type` information');\n  }\n  this.type = type;\n  this.cls = cls;\n  this.sub = sub;\n}\n\nType.prototype = {\n  toString: function(sep) {\n    sep = sep || ';';\n    var str = [this.type];\n    if (this.cls) {\n      str.push(this.cls);\n    }\n    if (this.sub) {\n      str.push(this.sub);\n    }\n    return str.join(sep);\n  },\n\n  toTryTypes: function() {\n    var _types = [];\n    if (this.sub) {\n      _types.push(new Type(this.type, this.cls, this.sub));\n    }\n    if (this.cls) {\n      _types.push(new Type(this.type, this.cls));\n    }\n    _types.push(new Type(this.type));\n\n    return _types;\n  }\n};\n\nvar toString = Object.prototype.toString;\n\n\n\n/**\n * Function to store type checks\n * @private\n */\nfunction TypeChecker() {\n  this.checks = [];\n}\n\nTypeChecker.prototype = {\n  add: function(func) {\n    this.checks.push(func);\n    return this;\n  },\n\n  addBeforeFirstMatch: function(obj, func) {\n    var match = this.getFirstMatch(obj);\n    if (match) {\n      this.checks.splice(match.index, 0, func);\n    } else {\n      this.add(func);\n    }\n  },\n\n  addTypeOf: function(type, res) {\n    return this.add(function(obj, tpeOf) {\n      if (tpeOf === type) {\n        return new Type(res);\n      }\n    });\n  },\n\n  addClass: function(cls, res, sub) {\n    return this.add(function(obj, tpeOf, objCls) {\n      if (objCls === cls) {\n        return new Type(types.OBJECT, res, sub);\n      }\n    });\n  },\n\n  getFirstMatch: function(obj) {\n    var typeOf = typeof obj;\n    var cls = toString.call(obj);\n\n    for (var i = 0, l = this.checks.length; i < l; i++) {\n      var res = this.checks[i].call(this, obj, typeOf, cls);\n      if (typeof res !== 'undefined') {\n        return { result: res, func: this.checks[i], index: i };\n      }\n    }\n  },\n\n  getType: function(obj) {\n    var match = this.getFirstMatch(obj);\n    return match && match.result;\n  }\n};\n\nvar main = new TypeChecker();\n\n//TODO add iterators\n\nmain\n  .addTypeOf(types.NUMBER, types.NUMBER)\n  .addTypeOf(types.UNDEFINED, types.UNDEFINED)\n  .addTypeOf(types.STRING, types.STRING)\n  .addTypeOf(types.BOOLEAN, types.BOOLEAN)\n  .addTypeOf(types.FUNCTION, types.FUNCTION)\n  .addTypeOf(types.SYMBOL, types.SYMBOL)\n  .add(function(obj) {\n    if (obj === null) {\n      return new Type(types.NULL);\n    }\n  })\n  .addClass('[object String]', types.STRING)\n  .addClass('[object Boolean]', types.BOOLEAN)\n  .addClass('[object Number]', types.NUMBER)\n  .addClass('[object Array]', types.ARRAY)\n  .addClass('[object RegExp]', types.REGEXP)\n  .addClass('[object Error]', types.ERROR)\n  .addClass('[object Date]', types.DATE)\n  .addClass('[object Arguments]', types.ARGUMENTS)\n\n  .addClass('[object ArrayBuffer]', types.ARRAY_BUFFER)\n  .addClass('[object Int8Array]', types.TYPED_ARRAY, 'int8')\n  .addClass('[object Uint8Array]', types.TYPED_ARRAY, 'uint8')\n  .addClass('[object Uint8ClampedArray]', types.TYPED_ARRAY, 'uint8clamped')\n  .addClass('[object Int16Array]', types.TYPED_ARRAY, 'int16')\n  .addClass('[object Uint16Array]', types.TYPED_ARRAY, 'uint16')\n  .addClass('[object Int32Array]', types.TYPED_ARRAY, 'int32')\n  .addClass('[object Uint32Array]', types.TYPED_ARRAY, 'uint32')\n  .addClass('[object Float32Array]', types.TYPED_ARRAY, 'float32')\n  .addClass('[object Float64Array]', types.TYPED_ARRAY, 'float64')\n\n  .addClass('[object Bool16x8]', types.SIMD, 'bool16x8')\n  .addClass('[object Bool32x4]', types.SIMD, 'bool32x4')\n  .addClass('[object Bool8x16]', types.SIMD, 'bool8x16')\n  .addClass('[object Float32x4]', types.SIMD, 'float32x4')\n  .addClass('[object Int16x8]', types.SIMD, 'int16x8')\n  .addClass('[object Int32x4]', types.SIMD, 'int32x4')\n  .addClass('[object Int8x16]', types.SIMD, 'int8x16')\n  .addClass('[object Uint16x8]', types.SIMD, 'uint16x8')\n  .addClass('[object Uint32x4]', types.SIMD, 'uint32x4')\n  .addClass('[object Uint8x16]', types.SIMD, 'uint8x16')\n\n  .addClass('[object DataView]', types.DATA_VIEW)\n  .addClass('[object Map]', types.MAP)\n  .addClass('[object WeakMap]', types.WEAK_MAP)\n  .addClass('[object Set]', types.SET)\n  .addClass('[object WeakSet]', types.WEAK_SET)\n  .addClass('[object Promise]', types.PROMISE)\n  .addClass('[object Blob]', types.BLOB)\n  .addClass('[object File]', types.FILE)\n  .addClass('[object FileList]', types.FILE_LIST)\n  .addClass('[object XMLHttpRequest]', types.XHR)\n  .add(function(obj) {\n    if ((typeof Promise === types.FUNCTION && obj instanceof Promise) ||\n        (typeof obj.then === types.FUNCTION)) {\n          return new Type(types.OBJECT, types.PROMISE);\n        }\n  })\n  .add(function(obj) {\n    if (typeof Buffer !== 'undefined' && obj instanceof Buffer) {// eslint-disable-line no-undef\n      return new Type(types.OBJECT, types.BUFFER);\n    }\n  })\n  .add(function(obj) {\n    if (typeof Node !== 'undefined' && obj instanceof Node) {\n      return new Type(types.OBJECT, types.HTML_ELEMENT, obj.nodeName);\n    }\n  })\n  .add(function(obj) {\n    // probably at the begginging should be enough these checks\n    if (obj.Boolean === Boolean && obj.Number === Number && obj.String === String && obj.Date === Date) {\n      return new Type(types.OBJECT, types.HOST);\n    }\n  })\n  .add(function() {\n    return new Type(types.OBJECT);\n  });\n\n/**\n * Get type information of anything\n *\n * @param  {any} obj Anything that could require type information\n * @return {Type}    type info\n * @private\n */\nfunction getGlobalType(obj) {\n  return main.getType(obj);\n}\n\ngetGlobalType.checker = main;\ngetGlobalType.TypeChecker = TypeChecker;\ngetGlobalType.Type = Type;\n\nObject.keys(types).forEach(function(typeName) {\n  getGlobalType[typeName] = types[typeName];\n});\n\nmodule.exports = getGlobalType;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/should-type/cjs/should-type.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar shouldUtil = require('should-util');\nvar t = _interopDefault(require('should-type'));\n\n// TODO in future add generators instead of forEach and iterator implementation\n\n\nfunction ObjectIterator(obj) {\n  this._obj = obj;\n}\n\nObjectIterator.prototype = {\n  __shouldIterator__: true, // special marker\n\n  next: function() {\n    if (this._done) {\n      throw new Error('Iterator already reached the end');\n    }\n\n    if (!this._keys) {\n      this._keys = Object.keys(this._obj);\n      this._index = 0;\n    }\n\n    var key = this._keys[this._index];\n    this._done = this._index === this._keys.length;\n    this._index += 1;\n\n    return {\n      value: this._done ? void 0: [key, this._obj[key]],\n      done: this._done\n    };\n  }\n};\n\nif (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n  ObjectIterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n}\n\n\nfunction TypeAdaptorStorage() {\n  this._typeAdaptors = [];\n  this._iterableTypes = {};\n}\n\nTypeAdaptorStorage.prototype = {\n  add: function(type, cls, sub, adaptor) {\n    return this.addType(new t.Type(type, cls, sub), adaptor);\n  },\n\n  addType: function(type, adaptor) {\n    this._typeAdaptors[type.toString()] = adaptor;\n  },\n\n  getAdaptor: function(tp, funcName) {\n    var tries = tp.toTryTypes();\n    while (tries.length) {\n      var toTry = tries.shift();\n      var ad = this._typeAdaptors[toTry];\n      if (ad && ad[funcName]) {\n        return ad[funcName];\n      }\n    }\n  },\n\n  requireAdaptor: function(tp, funcName) {\n    var a = this.getAdaptor(tp, funcName);\n    if (!a) {\n      throw new Error('There is no type adaptor `' + funcName + '` for ' + tp.toString());\n    }\n    return a;\n  },\n\n  addIterableType: function(tp) {\n    this._iterableTypes[tp.toString()] = true;\n  },\n\n  isIterableType: function(tp) {\n    return !!this._iterableTypes[tp.toString()];\n  }\n};\n\nvar defaultTypeAdaptorStorage = new TypeAdaptorStorage();\n\nvar objectAdaptor = {\n  forEach: function(obj, f, context) {\n    for (var prop in obj) {\n      if (shouldUtil.hasOwnProperty(obj, prop) && shouldUtil.propertyIsEnumerable(obj, prop)) {\n        if (f.call(context, obj[prop], prop, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n\n  has: function(obj, prop) {\n    return shouldUtil.hasOwnProperty(obj, prop);\n  },\n\n  get: function(obj, prop) {\n    return obj[prop];\n  },\n\n  iterator: function(obj) {\n    return new ObjectIterator(obj);\n  }\n};\n\n// default for objects\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT), objectAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.FUNCTION), objectAdaptor);\n\nvar mapAdaptor = {\n  has: function(obj, key) {\n    return obj.has(key);\n  },\n\n  get: function(obj, key) {\n    return obj.get(key);\n  },\n\n  forEach: function(obj, f, context) {\n    var iter = obj.entries();\n    forEach(iter, function(value) {\n      return f.call(context, value[1], value[0], obj);\n    });\n  },\n\n  size: function(obj) {\n    return obj.size;\n  },\n\n  isEmpty: function(obj) {\n    return obj.size === 0;\n  },\n\n  iterator: function(obj) {\n    return obj.entries();\n  }\n};\n\nvar setAdaptor = shouldUtil.merge({}, mapAdaptor);\nsetAdaptor.get = function(obj, key) {\n  if (obj.has(key)) {\n    return key;\n  }\n};\n\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.MAP), mapAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.SET), setAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_SET), setAdaptor);\ndefaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_MAP), mapAdaptor);\n\ndefaultTypeAdaptorStorage.addType(new t.Type(t.STRING), {\n  isEmpty: function(obj) {\n    return obj === '';\n  },\n\n  size: function(obj) {\n    return obj.length;\n  }\n});\n\ndefaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARRAY));\ndefaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARGUMENTS));\n\nfunction forEach(obj, f, context) {\n  if (shouldUtil.isGeneratorFunction(obj)) {\n    return forEach(obj(), f, context);\n  } else if (shouldUtil.isIterator(obj)) {\n    var value = obj.next();\n    while (!value.done) {\n      if (f.call(context, value.value, 'value', obj) === false) {\n        return;\n      }\n      value = obj.next();\n    }\n  } else {\n    var type = t(obj);\n    var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'forEach');\n    func(obj, f, context);\n  }\n}\n\n\nfunction size(obj) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'size');\n  if (func) {\n    return func(obj);\n  } else {\n    var len = 0;\n    forEach(obj, function() {\n      len += 1;\n    });\n    return len;\n  }\n}\n\nfunction isEmpty(obj) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'isEmpty');\n  if (func) {\n    return func(obj);\n  } else {\n    var res = true;\n    forEach(obj, function() {\n      res = false;\n      return false;\n    });\n    return res;\n  }\n}\n\n// return boolean if obj has such 'key'\nfunction has(obj, key) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'has');\n  return func(obj, key);\n}\n\n// return value for given key\nfunction get(obj, key) {\n  var type = t(obj);\n  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'get');\n  return func(obj, key);\n}\n\nfunction reduce(obj, f, initialValue) {\n  var res = initialValue;\n  forEach(obj, function(value, key) {\n    res = f(res, value, key, obj);\n  });\n  return res;\n}\n\nfunction some(obj, f, context) {\n  var res = false;\n  forEach(obj, function(value, key) {\n    if (f.call(context, value, key, obj)) {\n      res = true;\n      return false;\n    }\n  }, context);\n  return res;\n}\n\nfunction every(obj, f, context) {\n  var res = true;\n  forEach(obj, function(value, key) {\n    if (!f.call(context, value, key, obj)) {\n      res = false;\n      return false;\n    }\n  }, context);\n  return res;\n}\n\nfunction isIterable(obj) {\n  return defaultTypeAdaptorStorage.isIterableType(t(obj));\n}\n\nfunction iterator(obj) {\n  return defaultTypeAdaptorStorage.requireAdaptor(t(obj), 'iterator')(obj);\n}\n\nexports.defaultTypeAdaptorStorage = defaultTypeAdaptorStorage;\nexports.forEach = forEach;\nexports.size = size;\nexports.isEmpty = isEmpty;\nexports.has = has;\nexports.get = get;\nexports.reduce = reduce;\nexports.some = some;\nexports.every = every;\nexports.isIterable = isIterable;\nexports.iterator = iterator;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/should-type-adaptors/cjs/should-type-adaptors.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _propertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction hasOwnProperty(obj, key) {\n  return _hasOwnProperty.call(obj, key);\n}\n\nfunction propertyIsEnumerable(obj, key) {\n  return _propertyIsEnumerable.call(obj, key);\n}\n\nfunction merge(a, b) {\n  if (a && b) {\n    for (var key in b) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n}\n\nfunction isIterator(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (obj.__shouldIterator__) {\n    return true;\n  }\n\n  return typeof obj.next === 'function' &&\n    typeof Symbol === 'function' &&\n    typeof Symbol.iterator === 'symbol' &&\n    typeof obj[Symbol.iterator] === 'function' &&\n    obj[Symbol.iterator]() === obj;\n}\n\n//TODO find better way\nfunction isGeneratorFunction(f) {\n  return typeof f === 'function' && /^function\\s*\\*\\s*/.test(f.toString());\n}\n\nexports.hasOwnProperty = hasOwnProperty;\nexports.propertyIsEnumerable = propertyIsEnumerable;\nexports.merge = merge;\nexports.isIterator = isIterator;\nexports.isGeneratorFunction = isGeneratorFunction;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/should-util/cjs/should-util.js\n// module id = 2\n// module chunks = 0","\"use strict\";\r\n\r\n/*;\r\n\t@test-license:\r\n\t\tThe MIT License (MIT)\r\n\t\t@mit-license\r\n\r\n\t\tCopyright (@c) 2017 Richeve Siodina Bebedor\r\n\t\t@email: richeve.bebedor@gmail.com\r\n\r\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy\r\n\t\tof this software and associated documentation files (the \"Software\"), to deal\r\n\t\tin the Software without restriction, including without limitation the rights\r\n\t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n\t\tcopies of the Software, and to permit persons to whom the Software is\r\n\t\tfurnished to do so, subject to the following conditions:\r\n\r\n\t\tThe above copyright notice and this permission notice shall be included in all\r\n\t\tcopies or substantial portions of the Software.\r\n\r\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n\t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n\t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n\t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n\t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n\t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n\t\tSOFTWARE.\r\n\t@end-test-license\r\n\r\n\t@test-configuration:\r\n\t\t{\r\n\t\t\t\"package\": \"nmde\",\r\n\t\t\t\"path\": \"nmde/test.js\",\r\n\t\t\t\"file\": \"test.js\",\r\n\t\t\t\"module\": \"test\",\r\n\t\t\t\"author\": \"Richeve S. Bebedor\",\r\n\t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\r\n\t\t\t\"contributors\": [\r\n\t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\",\r\n\t\t\t\t\"Vinse Vinalon <vinsevinalon@gmail.com>\"\r\n\t\t\t],\r\n\t\t\t\"repository\": \"https://github.com/volkovasystems/nmde.git\"\r\n\t\t}\r\n\t@end-test-configuration\r\n\r\n\t@test-documentation:\r\n\r\n\t@end-test-documentation\r\n\r\n\t@include:\r\n\t\t{\r\n\t\t\t\"assert\": \"should\",\r\n\t\t\t\"nmde\": \"nmde\"\r\n\t\t}\r\n\t@end-include\r\n*/\r\n\r\nconst assert = require( \"should\" );\r\n\r\n\r\n\r\n//: @client:\r\nconst nmde = require( \"./nmde.support.js\" );\r\n//: @end-client\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//: @client:\r\n\r\ndescribe( \"nmde\", ( ) => {\r\n\r\n\r\n\tdescribe( \"`nmde( { 'name': 'yeah' } )`\", ( ) => {\r\n\r\n\t\tit( \"should return 'yeah'\", ( ) => {\r\n\r\n\t\t\tassert.equal( nmde( { 'name': 'yeah' } ), \"yeah\" );\r\n\r\n\t\t} );\r\n\r\n\t} );\r\n\r\n\r\n\tdescribe( \"`nmde( function hello( ){ } )`\", ( ) => {\r\n\r\n\t\tit( \"should return 'hello'\", ( ) => {\r\n\r\n\t\t\tassert.equal( nmde( function hello( ){ } ), \"hello\" );\r\n\r\n\t\t} );\r\n\r\n\t} );\r\n\r\n\r\n\tdescribe( \"`nmde( Error )`\", ( ) => {\r\n\r\n\t\tit( \"should return 'Error'\", ( ) => {\r\n\r\n\t\t\tassert.equal( nmde( Error ), \"Error\" );\r\n\r\n\t\t} );\r\n\r\n\t} );\r\n\r\n\r\n\tdescribe( \"`nmde( ) == ''`\", ( ) => {\r\n\r\n\t\tit( \"should return true\", ( ) => {\r\n\r\n\t\t\tassert.equal( nmde( ) == \"\", true );\r\n\r\n\t\t} );\r\n\r\n\t} );\r\n\r\n\r\n\tdescribe( \"`nmde( 'test' ) == ''`\", ( ) => {\r\n\r\n\t\tit( \"should return true\", ( ) => {\r\n\r\n\t\t\tassert.equal( nmde( \"test\" ) == \"\", true );\r\n\r\n\t\t} );\r\n\r\n\t} );\r\n\r\n\r\n\tdescribe( \"`nmde( { } ) == ''`\", ( ) => {\r\n\r\n\t\tit( \"should return true\", ( ) => {\r\n\r\n\t\t\tassert.equal( nmde( { } ) == \"\", true );\r\n\r\n\t\t} );\r\n\r\n\t} );\r\n\r\n\r\n\tdescribe( \"`nmde( ( ) => { } ) == ''`\", ( ) => {\r\n\r\n\t\tit( \"should return true\", ( ) => {\r\n\r\n\t\t\tassert.equal( nmde( ( ) => { } ) == \"\", true );\r\n\r\n\t\t} );\r\n\r\n\t} );\r\n\r\n\r\n\tdescribe( \"`nmde( ( entity ) => ( typeof entity == 'string' ) ) == ''`\", ( ) => {\r\n\t\tit( \"should return true\", ( ) => {\r\n\t\t\tassert.equal( nmde( ( entity ) => ( typeof entity == \"string\" ) ) == \"\", true )\r\n\t\t} );\r\n\t} );\r\n\r\n\r\n} );\r\n\r\n//: @end-client\r\n\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// test.support.js","var should = require('./cjs/should');\n\nvar defaultProto = Object.prototype;\nvar defaultProperty = 'should';\n\n//Expose api via `Object#should`.\ntry {\n  var prevShould = should.extend(defaultProperty, defaultProto);\n  should._prevShould = prevShould;\n} catch(e) {\n  //ignore errors\n}\n\nmodule.exports = should;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/should/index.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar getType = _interopDefault(require('should-type'));\nvar eql = _interopDefault(require('should-equal'));\nvar sformat = _interopDefault(require('should-format'));\nvar shouldTypeAdaptors = require('should-type-adaptors');\nvar shouldUtil = require('should-util');\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\nfunction isWrapperType(obj) {\n  return obj instanceof Number ||\n    obj instanceof String ||\n    obj instanceof Boolean;\n}\n\n// XXX make it more strict: numbers, strings, symbols - and nothing else\nfunction convertPropertyName(name) {\n  return (typeof name === 'symbol') ? name : String(name);\n}\n\nvar functionName = sformat.functionName;\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar config = {\n  typeAdaptors: shouldTypeAdaptors.defaultTypeAdaptorStorage,\n\n  getFormatter: function(opts) {\n    return new sformat.Formatter(opts || config);\n  }\n};\n\nfunction format(value, opts) {\n  return config.getFormatter(opts).format(value);\n}\n\nfunction formatProp(value) {\n  var formatter = config.getFormatter();\n  return sformat.formatPlainObjectKey.call(formatter, value);\n}\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n/**\n * should AssertionError\n * @param {Object} options\n * @constructor\n * @memberOf should\n * @static\n */\nfunction AssertionError(options) {\n  shouldUtil.merge(this, options);\n\n  if (!options.message) {\n    Object.defineProperty(this, 'message', {\n        get: function() {\n          if (!this._message) {\n            this._message = this.generateMessage();\n            this.generatedMessage = true;\n          }\n          return this._message;\n        },\n        configurable: true,\n        enumerable: false\n      }\n    );\n  }\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      if (this.stackStartFunction) {\n        // try to strip useless frames\n        var fn_name = functionName(this.stackStartFunction);\n        var idx = out.indexOf('\\n' + fn_name);\n        if (idx >= 0) {\n          // once we have located the function frame\n          // we need to strip out everything before it (and its line)\n          var next_line = out.indexOf('\\n', idx + 1);\n          out = out.substring(next_line + 1);\n        }\n      }\n\n      this.stack = out;\n    }\n  }\n}\n\n\nvar indent = '    ';\nfunction prependIndent(line) {\n  return indent + line;\n}\n\nfunction indentLines(text) {\n  return text.split('\\n').map(prependIndent).join('\\n');\n}\n\n\n// assert.AssertionError instanceof Error\nAssertionError.prototype = Object.create(Error.prototype, {\n  name: {\n    value: 'AssertionError'\n  },\n\n  generateMessage: {\n    value: function() {\n      if (!this.operator && this.previous) {\n        return this.previous.message;\n      }\n      var actual = format(this.actual);\n      var expected = 'expected' in this ? ' ' + format(this.expected) : '';\n      var details = 'details' in this && this.details ? ' (' + this.details + ')' : '';\n\n      var previous = this.previous ? '\\n' + indentLines(this.previous.message) : '';\n\n      return 'expected ' + actual + (this.negate ? ' not ' : ' ') + this.operator + expected + details + previous;\n    }\n  }\n});\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\n// a bit hacky way how to get error to do not have stack\nfunction LightAssertionError(options) {\n  shouldUtil.merge(this, options);\n\n  if (!options.message) {\n    Object.defineProperty(this, 'message', {\n      get: function() {\n        if (!this._message) {\n          this._message = this.generateMessage();\n          this.generatedMessage = true;\n        }\n        return this._message;\n      }\n    });\n  }\n}\n\nLightAssertionError.prototype = {\n  generateMessage: AssertionError.prototype.generateMessage\n};\n\n\n/**\n * should Assertion\n * @param {*} obj Given object for assertion\n * @constructor\n * @memberOf should\n * @static\n */\nfunction Assertion(obj) {\n  this.obj = obj;\n\n  this.anyOne = false;\n  this.negate = false;\n\n  this.params = {actual: obj};\n}\n\nAssertion.prototype = {\n  constructor: Assertion,\n\n  /**\n   * Base method for assertions.\n   *\n   * Before calling this method need to fill Assertion#params object. This method usually called from other assertion methods.\n   * `Assertion#params` can contain such properties:\n   * * `operator` - required string containing description of this assertion\n   * * `obj` - optional replacement for this.obj, it usefull if you prepare more clear object then given\n   * * `message` - if this property filled with string any others will be ignored and this one used as assertion message\n   * * `expected` - any object used when you need to assert relation between given object and expected. Like given == expected (== is a relation)\n   * * `details` - additional string with details to generated message\n   *\n   * @memberOf Assertion\n   * @category assertion\n   * @param {*} expr Any expression that will be used as a condition for asserting.\n   * @example\n   *\n   * var a = new should.Assertion(42);\n   *\n   * a.params = {\n   *  operator: 'to be magic number',\n   * }\n   *\n   * a.assert(false);\n   * //throws AssertionError: expected 42 to be magic number\n   */\n  assert: function(expr) {\n    if (expr) {\n      return this;\n    }\n\n    var params = this.params;\n\n    if ('obj' in params && !('actual' in params)) {\n      params.actual = params.obj;\n    } else if (!('obj' in params) && !('actual' in params)) {\n      params.actual = this.obj;\n    }\n\n    params.stackStartFunction = params.stackStartFunction || this.assert;\n    params.negate = this.negate;\n\n    params.assertion = this;\n\n    if (this.light) {\n      throw new LightAssertionError(params);\n    } else {\n      throw new AssertionError(params);\n    }\n  },\n\n  /**\n   * Shortcut for `Assertion#assert(false)`.\n   *\n   * @memberOf Assertion\n   * @category assertion\n   * @example\n   *\n   * var a = new should.Assertion(42);\n   *\n   * a.params = {\n   *  operator: 'to be magic number',\n   * }\n   *\n   * a.fail();\n   * //throws AssertionError: expected 42 to be magic number\n   */\n  fail: function() {\n    return this.assert(false);\n  }\n};\n\n\n\n/**\n * Assertion used to delegate calls of Assertion methods inside of Promise.\n * It has almost all methods of Assertion.prototype\n *\n * @param {Promise} obj\n */\nfunction PromisedAssertion(/* obj */) {\n  Assertion.apply(this, arguments);\n}\n\n/**\n * Make PromisedAssertion to look like promise. Delegate resolve and reject to given promise.\n *\n * @private\n * @returns {Promise}\n */\nPromisedAssertion.prototype.then = function(resolve, reject) {\n  return this.obj.then(resolve, reject);\n};\n\n/**\n * Way to extend Assertion function. It uses some logic\n * to define only positive assertions and itself rule with negative assertion.\n *\n * All actions happen in subcontext and this method take care about negation.\n * Potentially we can add some more modifiers that does not depends from state of assertion.\n *\n * @memberOf Assertion\n * @static\n * @param {String} name Name of assertion. It will be used for defining method or getter on Assertion.prototype\n * @param {Function} func Function that will be called on executing assertion\n * @example\n *\n * Assertion.add('asset', function() {\n *      this.params = { operator: 'to be asset' }\n *\n *      this.obj.should.have.property('id').which.is.a.Number()\n *      this.obj.should.have.property('path')\n * })\n */\nAssertion.add = function(name, func) {\n  Object.defineProperty(Assertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    value: function() {\n      var context = new Assertion(this.obj, this, name);\n      context.anyOne = this.anyOne;\n      context.onlyThis = this.onlyThis;\n      // hack\n      context.light = true;\n\n      try {\n        func.apply(context, arguments);\n      } catch (e) {\n        // check for fail\n        if (e instanceof AssertionError || e instanceof LightAssertionError) {\n          // negative fail\n          if (this.negate) {\n            this.obj = context.obj;\n            this.negate = false;\n            return this;\n          }\n\n          if (context !== e.assertion) {\n            context.params.previous = e;\n          }\n\n          // positive fail\n          context.negate = false;\n          // hack\n          context.light = false;\n          context.fail();\n        }\n        // throw if it is another exception\n        throw e;\n      }\n\n      // negative pass\n      if (this.negate) {\n        context.negate = true; // because .fail will set negate\n        context.params.details = 'false negative fail';\n        // hack\n        context.light = false;\n        context.fail();\n      }\n\n      // positive pass\n      if (!this.params.operator) {\n        this.params = context.params; // shortcut\n      }\n      this.obj = context.obj;\n      this.negate = false;\n      return this;\n    }\n  });\n\n  Object.defineProperty(PromisedAssertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    value: function() {\n      var args = arguments;\n      this.obj = this.obj.then(function(a) {\n        return a[name].apply(a, args);\n      });\n\n      return this;\n    }\n  });\n};\n\n/**\n * Add chaining getter to Assertion like .a, .which etc\n *\n * @memberOf Assertion\n * @static\n * @param  {string} name   name of getter\n * @param  {function} [onCall] optional function to call\n */\nAssertion.addChain = function(name, onCall) {\n  onCall = onCall || function() {};\n  Object.defineProperty(Assertion.prototype, name, {\n    get: function() {\n      onCall.call(this);\n      return this;\n    },\n    enumerable: true\n  });\n\n  Object.defineProperty(PromisedAssertion.prototype, name, {\n    enumerable: true,\n    configurable: true,\n    get: function() {\n      this.obj = this.obj.then(function(a) {\n        return a[name];\n      });\n\n      return this;\n    }\n  });\n};\n\n/**\n * Create alias for some `Assertion` property\n *\n * @memberOf Assertion\n * @static\n * @param {String} from Name of to map\n * @param {String} to Name of alias\n * @example\n *\n * Assertion.alias('true', 'True')\n */\nAssertion.alias = function(from, to) {\n  var desc = Object.getOwnPropertyDescriptor(Assertion.prototype, from);\n  if (!desc) {\n    throw new Error('Alias ' + from + ' -> ' + to + ' could not be created as ' + from + ' not defined');\n  }\n  Object.defineProperty(Assertion.prototype, to, desc);\n\n  var desc2 = Object.getOwnPropertyDescriptor(PromisedAssertion.prototype, from);\n  if (desc2) {\n    Object.defineProperty(PromisedAssertion.prototype, to, desc2);\n  }\n};\n/**\n * Negation modifier. Current assertion chain become negated. Each call invert negation on current assertion.\n *\n * @name not\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain('not', function() {\n  this.negate = !this.negate;\n});\n\n/**\n * Any modifier - it affect on execution of sequenced assertion to do not `check all`, but `check any of`.\n *\n * @name any\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain('any', function() {\n  this.anyOne = true;\n});\n\n\n/**\n * Only modifier - currently used with .keys to check if object contains only exactly this .keys\n *\n * @name only\n * @property\n * @memberOf Assertion\n * @category assertion\n */\nAssertion.addChain('only', function() {\n  this.onlyThis = true;\n});\n\n// implement assert interface using already written peaces of should.js\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// when used in node, this will actually load the util module we depend on\n// versus loading the builtin util module as happens otherwise\n// this is a bug in node module loading as far as I am concerned\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = ok;\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n/**\n * Node.js standard [`assert.fail`](http://nodejs.org/api/assert.html#assert_assert_fail_actual_expected_message_operator).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual Actual object\n * @param {*} expected Expected object\n * @param {string} message Message for assertion\n * @param {string} operator Operator text\n */\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  var a = new Assertion(actual);\n  a.params = {\n    operator: operator,\n    expected: expected,\n    message: message,\n    stackStartFunction: stackStartFunction || fail\n  };\n\n  a.fail();\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n/**\n * Node.js standard [`assert.ok`](http://nodejs.org/api/assert.html#assert_assert_value_message_assert_ok_value_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} value\n * @param {string} [message]\n */\nfunction ok(value, message) {\n  if (!value) {\n    fail(value, true, message, '==', assert.ok);\n  }\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\n/**\n * Node.js standard [`assert.equal`](http://nodejs.org/api/assert.html#assert_assert_equal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) {\n    fail(actual, expected, message, '==', assert.equal);\n  }\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notEqual`](http://nodejs.org/api/assert.html#assert_assert_notequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.deepEqual`](http://nodejs.org/api/assert.html#assert_assert_deepequal_actual_expected_message).\n * But uses should.js .eql implementation instead of Node.js own deepEqual.\n *\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (eql(actual, expected).length !== 0) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notDeepEqual`](http://nodejs.org/api/assert.html#assert_assert_notdeepequal_actual_expected_message).\n * But uses should.js .eql implementation instead of Node.js own deepEqual.\n *\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (eql(actual, expected).result) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.strictEqual`](http://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n/**\n * Node.js standard [`assert.notStrictEqual`](http://nodejs.org/api/assert.html#assert_assert_notstrictequal_actual_expected_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {*} actual\n * @param {*} expected\n * @param {string} [message]\n */\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected == 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ')' : '.') +\n  (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n/**\n * Node.js standard [`assert.throws`](http://nodejs.org/api/assert.html#assert_assert_throws_block_error_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Function} block\n * @param {Function} [error]\n * @param {String} [message]\n */\nassert.throws = function(/*block, error, message*/) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\n/**\n * Node.js standard [`assert.doesNotThrow`](http://nodejs.org/api/assert.html#assert_assert_doesnotthrow_block_message).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Function} block\n * @param {String} [message]\n */\nassert.doesNotThrow = function(/*block, message*/) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\n/**\n * Node.js standard [`assert.ifError`](http://nodejs.org/api/assert.html#assert_assert_iferror_value).\n * @static\n * @memberOf should\n * @category assertion assert\n * @param {Error} err\n */\nassert.ifError = function(err) {\n  if (err) {\n    throw err;\n  }\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar assertExtensions = function(should) {\n  var i = should.format;\n\n  /*\n   * Expose assert to should\n   *\n   * This allows you to do things like below\n   * without require()ing the assert module.\n   *\n   *    should.equal(foo.bar, undefined);\n   *\n   */\n  shouldUtil.merge(should, assert);\n\n  /**\n   * Assert _obj_ exists, with optional message.\n   *\n   * @static\n   * @memberOf should\n   * @category assertion assert\n   * @alias should.exists\n   * @param {*} obj\n   * @param {String} [msg]\n   * @example\n   *\n   * should.exist(1);\n   * should.exist(new Date());\n   */\n  should.exist = should.exists = function(obj, msg) {\n    if (null == obj) {\n      throw new AssertionError({\n        message: msg || ('expected ' + i(obj) + ' to exist'), stackStartFunction: should.exist\n      });\n    }\n  };\n\n  should.not = {};\n  /**\n   * Asserts _obj_ does not exist, with optional message.\n   *\n   * @name not.exist\n   * @static\n   * @memberOf should\n   * @category assertion assert\n   * @alias should.not.exists\n   * @param {*} obj\n   * @param {String} [msg]\n   * @example\n   *\n   * should.not.exist(null);\n   * should.not.exist(void 0);\n   */\n  should.not.exist = should.not.exists = function(obj, msg) {\n    if (null != obj) {\n      throw new AssertionError({\n        message: msg || ('expected ' + i(obj) + ' to not exist'), stackStartFunction: should.not.exist\n      });\n    }\n  };\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar chainAssertions = function(should, Assertion) {\n  /**\n   * Simple chaining to improve readability. Does nothing.\n   *\n   * @memberOf Assertion\n   * @name be\n   * @property {should.Assertion} be\n   * @alias Assertion#an\n   * @alias Assertion#of\n   * @alias Assertion#a\n   * @alias Assertion#and\n   * @alias Assertion#been\n   * @alias Assertion#have\n   * @alias Assertion#has\n   * @alias Assertion#with\n   * @alias Assertion#is\n   * @alias Assertion#which\n   * @alias Assertion#the\n   * @alias Assertion#it\n   * @category assertion chaining\n   */\n  ['an', 'of', 'a', 'and', 'be', 'been', 'has', 'have', 'with', 'is', 'which', 'the', 'it'].forEach(function(name) {\n    Assertion.addChain(name);\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar booleanAssertions = function(should, Assertion) {\n  /**\n   * Assert given object is exactly `true`.\n   *\n   * @name true\n   * @memberOf Assertion\n   * @category assertion bool\n   * @alias Assertion#True\n   * @param {string} [message] Optional message\n   * @example\n   *\n   * (true).should.be.true();\n   * false.should.not.be.true();\n   *\n   * ({ a: 10}).should.not.be.true();\n   */\n  Assertion.add('true', function(message) {\n    this.is.exactly(true, message);\n  });\n\n  Assertion.alias('true', 'True');\n\n  /**\n   * Assert given object is exactly `false`.\n   *\n   * @name false\n   * @memberOf Assertion\n   * @category assertion bool\n   * @alias Assertion#False\n   * @param {string} [message] Optional message\n   * @example\n   *\n   * (true).should.not.be.false();\n   * false.should.be.false();\n   */\n  Assertion.add('false', function(message) {\n    this.is.exactly(false, message);\n  });\n\n  Assertion.alias('false', 'False');\n\n  /**\n   * Assert given object is truthy according javascript type conversions.\n   *\n   * @name ok\n   * @memberOf Assertion\n   * @category assertion bool\n   * @example\n   *\n   * (true).should.be.ok();\n   * ''.should.not.be.ok();\n   * should(null).not.be.ok();\n   * should(void 0).not.be.ok();\n   *\n   * (10).should.be.ok();\n   * (0).should.not.be.ok();\n   */\n  Assertion.add('ok', function() {\n    this.params = { operator: 'to be truthy' };\n\n    this.assert(this.obj);\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar numberAssertions = function(should, Assertion) {\n\n  /**\n   * Assert given object is NaN\n   * @name NaN\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @example\n   *\n   * (10).should.not.be.NaN();\n   * NaN.should.be.NaN();\n   */\n  Assertion.add('NaN', function() {\n    this.params = { operator: 'to be NaN' };\n\n    this.assert(this.obj !== this.obj);\n  });\n\n  /**\n   * Assert given object is not finite (positive or negative)\n   *\n   * @name Infinity\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @example\n   *\n   * (10).should.not.be.Infinity();\n   * NaN.should.not.be.Infinity();\n   */\n  Assertion.add('Infinity', function() {\n    this.params = { operator: 'to be Infinity' };\n\n    this.is.a.Number()\n      .and.not.a.NaN()\n      .and.assert(!isFinite(this.obj));\n  });\n\n  /**\n   * Assert given number between `start` and `finish` or equal one of them.\n   *\n   * @name within\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} start Start number\n   * @param {number} finish Finish number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.within(0, 20);\n   */\n  Assertion.add('within', function(start, finish, description) {\n    this.params = { operator: 'to be within ' + start + '..' + finish, message: description };\n\n    this.assert(this.obj >= start && this.obj <= finish);\n  });\n\n  /**\n   * Assert given number near some other `value` within `delta`\n   *\n   * @name approximately\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} value Center number\n   * @param {number} delta Radius\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (9.99).should.be.approximately(10, 0.1);\n   */\n  Assertion.add('approximately', function(value, delta, description) {\n    this.params = { operator: 'to be approximately ' + value + ' ' + delta, message: description };\n\n    this.assert(Math.abs(this.obj - value) <= delta);\n  });\n\n  /**\n   * Assert given number above `n`.\n   *\n   * @name above\n   * @alias Assertion#greaterThan\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.above(0);\n   */\n  Assertion.add('above', function(n, description) {\n    this.params = { operator: 'to be above ' + n, message: description };\n\n    this.assert(this.obj > n);\n  });\n\n  /**\n   * Assert given number below `n`.\n   *\n   * @name below\n   * @alias Assertion#lessThan\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (0).should.be.below(10);\n   */\n  Assertion.add('below', function(n, description) {\n    this.params = { operator: 'to be below ' + n, message: description };\n\n    this.assert(this.obj < n);\n  });\n\n  Assertion.alias('above', 'greaterThan');\n  Assertion.alias('below', 'lessThan');\n\n  /**\n   * Assert given number above `n`.\n   *\n   * @name aboveOrEqual\n   * @alias Assertion#greaterThanOrEqual\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.aboveOrEqual(0);\n   * (10).should.be.aboveOrEqual(10);\n   */\n  Assertion.add('aboveOrEqual', function(n, description) {\n    this.params = { operator: 'to be above or equal' + n, message: description };\n\n    this.assert(this.obj >= n);\n  });\n\n  /**\n   * Assert given number below `n`.\n   *\n   * @name belowOrEqual\n   * @alias Assertion#lessThanOrEqual\n   * @memberOf Assertion\n   * @category assertion numbers\n   * @param {number} n Margin number\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (0).should.be.belowOrEqual(10);\n   * (0).should.be.belowOrEqual(0);\n   */\n  Assertion.add('belowOrEqual', function(n, description) {\n    this.params = { operator: 'to be below or equal' + n, message: description };\n\n    this.assert(this.obj <= n);\n  });\n\n  Assertion.alias('aboveOrEqual', 'greaterThanOrEqual');\n  Assertion.alias('belowOrEqual', 'lessThanOrEqual');\n\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar typeAssertions = function(should, Assertion) {\n  /**\n   * Assert given object is number\n   * @name Number\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Number', function() {\n    this.params = {operator: 'to be a number'};\n\n    this.have.type('number');\n  });\n\n  /**\n   * Assert given object is arguments\n   * @name arguments\n   * @alias Assertion#Arguments\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('arguments', function() {\n    this.params = {operator: 'to be arguments'};\n\n    this.have.class('Arguments');\n  });\n\n  Assertion.alias('arguments', 'Arguments');\n\n  /**\n   * Assert given object has some type using `typeof`\n   * @name type\n   * @memberOf Assertion\n   * @param {string} type Type name\n   * @param {string} [description] Optional message\n   * @category assertion types\n   */\n  Assertion.add('type', function(type, description) {\n    this.params = {operator: 'to have type ' + type, message: description};\n\n    should(typeof this.obj).be.exactly(type);\n  });\n\n  /**\n   * Assert given object is instance of `constructor`\n   * @name instanceof\n   * @alias Assertion#instanceOf\n   * @memberOf Assertion\n   * @param {Function} constructor Constructor function\n   * @param {string} [description] Optional message\n   * @category assertion types\n   */\n  Assertion.add('instanceof', function(constructor, description) {\n    this.params = {operator: 'to be an instance of ' + functionName(constructor), message: description};\n\n    this.assert(Object(this.obj) instanceof constructor);\n  });\n\n  Assertion.alias('instanceof', 'instanceOf');\n\n  /**\n   * Assert given object is function\n   * @name Function\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Function', function() {\n    this.params = {operator: 'to be a function'};\n\n    this.have.type('function');\n  });\n\n  /**\n   * Assert given object is object\n   * @name Object\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Object', function() {\n    this.params = {operator: 'to be an object'};\n\n    this.is.not.null().and.have.type('object');\n  });\n\n  /**\n   * Assert given object is string\n   * @name String\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('String', function() {\n    this.params = {operator: 'to be a string'};\n\n    this.have.type('string');\n  });\n\n  /**\n   * Assert given object is array\n   * @name Array\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Array', function() {\n    this.params = {operator: 'to be an array'};\n\n    this.have.class('Array');\n  });\n\n  /**\n   * Assert given object is boolean\n   * @name Boolean\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Boolean', function() {\n    this.params = {operator: 'to be a boolean'};\n\n    this.have.type('boolean');\n  });\n\n  /**\n   * Assert given object is error\n   * @name Error\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Error', function() {\n    this.params = {operator: 'to be an error'};\n\n    this.have.instanceOf(Error);\n  });\n\n  /**\n   * Assert given object is a date\n   * @name Date\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('Date', function() {\n    this.params = {operator: 'to be a date'};\n\n    this.have.instanceOf(Date);\n  });\n\n  /**\n   * Assert given object is null\n   * @name null\n   * @alias Assertion#Null\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('null', function() {\n    this.params = {operator: 'to be null'};\n\n    this.assert(this.obj === null);\n  });\n\n  Assertion.alias('null', 'Null');\n\n  /**\n   * Assert given object has some internal [[Class]], via Object.prototype.toString call\n   * @name class\n   * @alias Assertion#Class\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('class', function(cls) {\n    this.params = {operator: 'to have [[Class]] ' + cls};\n\n    this.assert(Object.prototype.toString.call(this.obj) === '[object ' + cls + ']');\n  });\n\n  Assertion.alias('class', 'Class');\n\n  /**\n   * Assert given object is undefined\n   * @name undefined\n   * @alias Assertion#Undefined\n   * @memberOf Assertion\n   * @category assertion types\n   */\n  Assertion.add('undefined', function() {\n    this.params = {operator: 'to be undefined'};\n\n    this.assert(this.obj === void 0);\n  });\n\n  Assertion.alias('undefined', 'Undefined');\n\n  /**\n   * Assert given object supports es6 iterable protocol (just check\n   * that object has property Symbol.iterator, which is a function)\n   * @name iterable\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add('iterable', function() {\n    this.params = {operator: 'to be iterable'};\n\n    should(this.obj).have.property(Symbol.iterator).which.is.a.Function();\n  });\n\n  /**\n   * Assert given object supports es6 iterator protocol (just check\n   * that object has property next, which is a function)\n   * @name iterator\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add('iterator', function() {\n    this.params = {operator: 'to be iterator'};\n\n    should(this.obj).have.property('next').which.is.a.Function();\n  });\n\n  /**\n   * Assert given object is a generator object\n   * @name generator\n   * @memberOf Assertion\n   * @category assertion es6\n   */\n  Assertion.add('generator', function() {\n    this.params = {operator: 'to be generator'};\n\n    should(this.obj).be.iterable\n      .and.iterator\n      .and.it.is.equal(this.obj[Symbol.iterator]());\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nfunction formatEqlResult(r, a, b) {\n  return ((r.path.length > 0 ? 'at ' + r.path.map(formatProp).join(' -> ') : '') +\n  (r.a === a ? '' : ', A has ' + format(r.a)) +\n  (r.b === b ? '' : ' and B has ' + format(r.b)) +\n  (r.showReason ? ' because ' + r.reason : '')).trim();\n}\n\nvar equalityAssertions = function(should, Assertion) {\n\n\n  /**\n   * Deep object equality comparison. For full spec see [`should-equal tests`](https://github.com/shouldjs/equal/blob/master/test.js).\n   *\n   * @name eql\n   * @memberOf Assertion\n   * @category assertion equality\n   * @alias Assertion#deepEqual\n   * @param {*} val Expected value\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * (10).should.be.eql(10);\n   * ('10').should.not.be.eql(10);\n   * (-0).should.not.be.eql(+0);\n   *\n   * NaN.should.be.eql(NaN);\n   *\n   * ({ a: 10}).should.be.eql({ a: 10 });\n   * [ 'a' ].should.not.be.eql({ '0': 'a' });\n   */\n  Assertion.add('eql', function(val, description) {\n    this.params = {operator: 'to equal', expected: val, message: description};\n    var obj = this.obj;\n    var fails = eql(this.obj, val, should.config);\n    this.params.details = fails.map(function(fail) {\n      return formatEqlResult(fail, obj, val);\n    }).join(', ');\n\n    this.params.showDiff = eql(getType(obj), getType(val)).length === 0;\n\n    this.assert(fails.length === 0);\n  });\n\n  /**\n   * Exact comparison using ===.\n   *\n   * @name equal\n   * @memberOf Assertion\n   * @category assertion equality\n   * @alias Assertion#exactly\n   * @param {*} val Expected value\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 10.should.be.equal(10);\n   * 'a'.should.be.exactly('a');\n   *\n   * should(null).be.exactly(null);\n   */\n  Assertion.add('equal', function(val, description) {\n    this.params = {operator: 'to be', expected: val, message: description};\n\n    this.params.showDiff = eql(getType(this.obj), getType(val)).length === 0;\n\n    this.assert(val === this.obj);\n  });\n\n  Assertion.alias('equal', 'exactly');\n  Assertion.alias('eql', 'deepEqual');\n\n  function addOneOf(name, message, method) {\n    Assertion.add(name, function(vals) {\n      if (arguments.length !== 1) {\n        vals = Array.prototype.slice.call(arguments);\n      } else {\n        should(vals).be.Array();\n      }\n\n      this.params = {operator: message, expected: vals};\n\n      var obj = this.obj;\n      var found = false;\n\n      shouldTypeAdaptors.forEach(vals, function(val) {\n        try {\n          should(val)[method](obj);\n          found = true;\n          return false;\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            return;//do nothing\n          }\n          throw e;\n        }\n      });\n\n      this.assert(found);\n    });\n  }\n\n  /**\n   * Exact comparison using === to be one of supplied objects.\n   *\n   * @name equalOneOf\n   * @memberOf Assertion\n   * @category assertion equality\n   * @param {Array|*} vals Expected values\n   * @example\n   *\n   * 'ab'.should.be.equalOneOf('a', 10, 'ab');\n   * 'ab'.should.be.equalOneOf(['a', 10, 'ab']);\n   */\n  addOneOf('equalOneOf', 'to be equals one of', 'equal');\n\n  /**\n   * Exact comparison using .eql to be one of supplied objects.\n   *\n   * @name oneOf\n   * @memberOf Assertion\n   * @category assertion equality\n   * @param {Array|*} vals Expected values\n   * @example\n   *\n   * ({a: 10}).should.be.oneOf('a', 10, 'ab', {a: 10});\n   * ({a: 10}).should.be.oneOf(['a', 10, 'ab', {a: 10}]);\n   */\n  addOneOf('oneOf', 'to be one of', 'eql');\n\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar promiseAssertions = function(should, Assertion$$1) {\n  /**\n   * Assert given object is a Promise\n   *\n   * @name Promise\n   * @memberOf Assertion\n   * @category assertion promises\n   * @example\n   *\n   * promise.should.be.Promise()\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.a.Promise()\n   * (10).should.not.be.a.Promise()\n   */\n  Assertion$$1.add('Promise', function() {\n    this.params = {operator: 'to be promise'};\n\n    var obj = this.obj;\n\n    should(obj).have.property('then')\n      .which.is.a.Function();\n  });\n\n  /**\n   * Assert given promise will be fulfilled. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilled\n   * @memberOf Assertion\n   * @returns {Promise}\n   * @category assertion promises\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.fulfilled();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.fulfilled();\n   * });\n   */\n  Assertion$$1.prototype.fulfilled = function Assertion$fulfilled() {\n    this.params = {operator: 'to be fulfilled'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function next$onResolve(value) {\n      if (that.negate) {\n        that.fail();\n      }\n      return value;\n    }, function next$onReject(err) {\n      if (!that.negate) {\n        that.params.operator += ', but it was rejected with ' + should.format(err);\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be rejected. Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejected\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.not.be.rejected();\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => reject(new Error('boom')))\n   *      .should.be.rejected();\n   * });\n   */\n  Assertion$$1.prototype.rejected = function() {\n    this.params = {operator: 'to be rejected'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (!that.negate) {\n        that.params.operator += ', but it was fulfilled';\n        if (arguments.length != 0) {\n          that.params.operator += ' with ' + should.format(value);\n        }\n        that.fail();\n      }\n      return value;\n    }, function next$onError(err) {\n      if (that.negate) {\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be fulfilled with some expected value (value compared using .eql).\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name fulfilledWith\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * // don't forget to handle async nature\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.fulfilledWith(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise((resolve, reject) => resolve(10))\n   *       .should.be.fulfilledWith(10);\n   * });\n   */\n  Assertion$$1.prototype.fulfilledWith = function(expectedValue) {\n    this.params = {operator: 'to be fulfilled with ' + should.format(expectedValue)};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (that.negate) {\n        that.fail();\n      }\n      should(value).eql(expectedValue);\n      return value;\n    }, function next$onError(err) {\n      if (!that.negate) {\n        that.params.operator += ', but it was rejected with ' + should.format(err);\n        that.fail();\n      }\n      return err;\n    });\n  };\n\n  /**\n   * Assert given promise will be rejected with some sort of error. Arguments is the same for Assertion#throw.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name rejectedWith\n   * @memberOf Assertion\n   * @category assertion promises\n   * @returns {Promise}\n   * @example\n   *\n   * function failedPromise() {\n   *   return new Promise(function(resolve, reject) {\n   *     reject(new Error('boom'))\n   *   })\n   * }\n   * failedPromise().should.be.rejectedWith(Error);\n   * failedPromise().should.be.rejectedWith('boom');\n   * failedPromise().should.be.rejectedWith(/boom/);\n   * failedPromise().should.be.rejectedWith(Error, { message: 'boom' });\n   * failedPromise().should.be.rejectedWith({ message: 'boom' });\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return failedPromise().should.be.rejectedWith({ message: 'boom' });\n   * });\n   */\n  Assertion$$1.prototype.rejectedWith = function(message, properties) {\n    this.params = {operator: 'to be rejected'};\n\n    should(this.obj).be.a.Promise();\n\n    var that = this;\n    return this.obj.then(function(value) {\n      if (!that.negate) {\n        that.fail();\n      }\n      return value;\n    }, function next$onError(err) {\n      if (that.negate) {\n        that.fail();\n      }\n\n      var errorMatched = true;\n      var errorInfo = '';\n\n      if ('string' === typeof message) {\n        errorMatched = message === err.message;\n      } else if (message instanceof RegExp) {\n        errorMatched = message.test(err.message);\n      } else if ('function' === typeof message) {\n        errorMatched = err instanceof message;\n      } else if (message !== null && typeof message === 'object') {\n        try {\n          should(err).match(message);\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            errorInfo = ': ' + e.message;\n            errorMatched = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      if (!errorMatched) {\n        if ( typeof message === 'string' || message instanceof RegExp) {\n          errorInfo = ' with a message matching ' + should.format(message) + \", but got '\" + err.message + \"'\";\n        } else if ('function' === typeof message) {\n          errorInfo = ' of type ' + functionName(message) + ', but got ' + functionName(err.constructor);\n        }\n      } else if ('function' === typeof message && properties) {\n        try {\n          should(err).match(properties);\n        } catch (e) {\n          if (e instanceof should.AssertionError) {\n            errorInfo = ': ' + e.message;\n            errorMatched = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      that.params.operator += errorInfo;\n\n      that.assert(errorMatched);\n\n      return err;\n    });\n  };\n\n  /**\n   * Assert given object is promise and wrap it in PromisedAssertion, which has all properties of Assertion.\n   * That means you can chain as with usual Assertion.\n   * Result of assertion is still .thenable and should be handled accordingly.\n   *\n   * @name finally\n   * @memberOf Assertion\n   * @alias Assertion#eventually\n   * @category assertion promises\n   * @returns {PromisedAssertion} Like Assertion, but .then this.obj in Assertion\n   * @example\n   *\n   * (new Promise(function(resolve, reject) { resolve(10); }))\n   *    .should.be.eventually.equal(10);\n   *\n   * // test example with mocha it is possible to return promise\n   * it('is async', () => {\n   *    return new Promise(resolve => resolve(10))\n   *      .should.be.finally.equal(10);\n   * });\n   */\n  Object.defineProperty(Assertion$$1.prototype, 'finally', {\n    get: function() {\n      should(this.obj).be.a.Promise();\n\n      var that = this;\n\n      return new PromisedAssertion(this.obj.then(function(obj) {\n        var a = should(obj);\n\n        a.negate = that.negate;\n        a.anyOne = that.anyOne;\n\n        return a;\n      }));\n    }\n  });\n\n  Assertion$$1.alias('finally', 'eventually');\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar stringAssertions = function(should, Assertion) {\n  /**\n   * Assert given string starts with prefix\n   * @name startWith\n   * @memberOf Assertion\n   * @category assertion strings\n   * @param {string} str Prefix\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 'abc'.should.startWith('a');\n   */\n  Assertion.add('startWith', function(str, description) {\n    this.params = { operator: 'to start with ' + should.format(str), message: description };\n\n    this.assert(0 === this.obj.indexOf(str));\n  });\n\n  /**\n   * Assert given string ends with prefix\n   * @name endWith\n   * @memberOf Assertion\n   * @category assertion strings\n   * @param {string} str Prefix\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * 'abca'.should.endWith('a');\n   */\n  Assertion.add('endWith', function(str, description) {\n    this.params = { operator: 'to end with ' + should.format(str), message: description };\n\n    this.assert(this.obj.indexOf(str, this.obj.length - str.length) >= 0);\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar containAssertions = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Assert that given object contain something that equal to `other`. It uses `should-equal` for equality checks.\n   * If given object is array it search that one of elements was equal to `other`.\n   * If given object is string it checks if `other` is a substring - expected that `other` is a string.\n   * If given object is Object it checks that `other` is a subobject - expected that `other` is a object.\n   *\n   * @name containEql\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [1, 2, 3].should.containEql(1);\n   * [{ a: 1 }, 'a', 10].should.containEql({ a: 1 });\n   *\n   * 'abc'.should.containEql('b');\n   * 'ab1c'.should.containEql(1);\n   *\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ a: 10 });\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ c: { d: 10 }});\n   * ({ a: 10, c: { d: 10 }}).should.containEql({ b: 10 });\n   * // throws AssertionError: expected { a: 10, c: { d: 10 } } to contain { b: 10 }\n   * //            expected { a: 10, c: { d: 10 } } to have property b\n   */\n  Assertion.add('containEql', function(other) {\n    this.params = { operator: 'to contain ' + i(other) };\n\n    this.is.not.null().and.not.undefined();\n\n    var obj = this.obj;\n\n    if (typeof obj == 'string') {\n      this.assert(obj.indexOf(String(other)) >= 0);\n    } else if (shouldTypeAdaptors.isIterable(obj)) {\n      this.assert(shouldTypeAdaptors.some(obj, function(v) {\n        return eql(v, other).length === 0;\n      }));\n    } else {\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj).have.value(key, value);\n      }, this);\n    }\n  });\n\n  /**\n   * Assert that given object is contain equally structured object on the same depth level.\n   * If given object is an array and `other` is an array it checks that the eql elements is going in the same sequence in given array (recursive)\n   * If given object is an object it checks that the same keys contain deep equal values (recursive)\n   * On other cases it try to check with `.eql`\n   *\n   * @name containDeepOrdered\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeepOrdered([1, 2]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeepOrdered([ 1, [ 2, 3 ]]);\n   *\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({a: 10});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {c: 10}});\n   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {d: [1, 3]}});\n   */\n  Assertion.add('containDeepOrdered', function(other) {\n    this.params = {operator: 'to contain ' + i(other)};\n\n    var obj = this.obj;\n    if (typeof obj == 'string') {// expect other to be string\n      this.is.equal(String(other));\n    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {\n      var objIterator = shouldTypeAdaptors.iterator(obj);\n      var otherIterator = shouldTypeAdaptors.iterator(other);\n\n      var nextObj = objIterator.next();\n      var nextOther = otherIterator.next();\n      while (!nextObj.done && !nextOther.done) {\n        try {\n          should(nextObj.value[1]).containDeepOrdered(nextOther.value[1]);\n          nextOther = otherIterator.next();\n        } catch (e) {\n          if (!(e instanceof should.AssertionError)) {\n            throw e;\n          }\n        }\n        nextObj = objIterator.next();\n      }\n\n      this.assert(nextOther.done);\n    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {//TODO compare types object contains object case\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj[key]).containDeepOrdered(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (shouldTypeAdaptors.isEmpty(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n\n  /**\n   * The same like `Assertion#containDeepOrdered` but all checks on arrays without order.\n   *\n   * @name containDeep\n   * @memberOf Assertion\n   * @category assertion contain\n   * @param {*} other Nested object\n   * @example\n   *\n   * [ 1, 2, 3].should.containDeep([2, 1]);\n   * [ 1, 2, [ 1, 2, 3 ]].should.containDeep([ 1, [ 3, 1 ]]);\n   */\n  Assertion.add('containDeep', function(other) {\n    this.params = {operator: 'to contain ' + i(other)};\n\n    var obj = this.obj;\n    if (typeof obj == 'string') {// expect other to be string\n      this.is.equal(String(other));\n    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {\n      var usedKeys = {};\n      shouldTypeAdaptors.forEach(other, function(otherItem) {\n        this.assert(shouldTypeAdaptors.some(obj, function(item, index) {\n          if (index in usedKeys) {\n            return false;\n          }\n\n          try {\n            should(item).containDeep(otherItem);\n            usedKeys[index] = true;\n            return true;\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              return false;\n            }\n            throw e;\n          }\n        }));\n      }, this);\n    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {// object contains object case\n      shouldTypeAdaptors.forEach(other, function(value, key) {\n        should(obj[key]).containDeep(value);\n      });\n\n      // if both objects is empty means we finish traversing - and we need to compare for hidden values\n      if (shouldTypeAdaptors.isEmpty(other)) {\n        this.eql(other);\n      }\n    } else {\n      this.eql(other);\n    }\n  });\n\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar aSlice = Array.prototype.slice;\n\nvar propertyAssertions = function(should, Assertion) {\n  var i = should.format;\n  /**\n   * Asserts given object has some descriptor. **On success it change given object to be value of property**.\n   *\n   * @name propertyWithDescriptor\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {Object} desc Descriptor like used in Object.defineProperty (not required to add all properties)\n   * @example\n   *\n   * ({ a: 10 }).should.have.propertyWithDescriptor('a', { enumerable: true });\n   */\n  Assertion.add('propertyWithDescriptor', function(name, desc) {\n    this.params = {actual: this.obj, operator: 'to have own property with descriptor ' + i(desc)};\n    var obj = this.obj;\n    this.have.ownProperty(name);\n    should(Object.getOwnPropertyDescriptor(Object(obj), name)).have.properties(desc);\n  });\n\n  function processPropsArgs() {\n    var args = {};\n    if (arguments.length > 1) {\n      args.names = aSlice.call(arguments);\n    } else {\n      var arg = arguments[0];\n      if (typeof arg === 'string') {\n        args.names = [arg];\n      } else if (Array.isArray(arg)) {\n        args.names = arg;\n      } else {\n        args.names = Object.keys(arg);\n        args.values = arg;\n      }\n    }\n    return args;\n  }\n\n  Assertion.add('enumerable', function(name, val) {\n    name = convertPropertyName(name);\n\n    this.params = {\n      operator: \"to have enumerable property \" + formatProp(name) + (arguments.length > 1 ? \" equal to \" + i(val): \"\")\n    };\n\n    var desc = { enumerable: true };\n    if (arguments.length > 1) {\n      desc.value = val;\n    }\n    this.have.propertyWithDescriptor(name, desc);\n  });\n\n  Assertion.add('enumerables', function(/*names*/) {\n    var args = processPropsArgs.apply(null, arguments);\n\n    this.params = {\n      operator: \"to have enumerables \" + args.names.map(formatProp)\n    };\n\n    var obj = this.obj;\n    args.names.forEach(function(name) {\n      should(obj).have.enumerable(name);\n    });\n  });\n\n  /**\n   * Asserts given object has property with optionally value. **On success it change given object to be value of property**.\n   *\n   * @name property\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {*} [val] Optional property value to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.property('a');\n   */\n  Assertion.add('property', function(name, val) {\n    name = convertPropertyName(name);\n    if (arguments.length > 1) {\n      var p = {};\n      p[name] = val;\n      this.have.properties(p);\n    } else {\n      this.have.properties(name);\n    }\n    this.obj = this.obj[name];\n  });\n\n  /**\n   * Asserts given object has properties. On this method affect .any modifier, which allow to check not all properties.\n   *\n   * @name properties\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string|Object} names Names of property\n   * @example\n   *\n   * ({ a: 10 }).should.have.properties('a');\n   * ({ a: 10, b: 20 }).should.have.properties([ 'a' ]);\n   * ({ a: 10, b: 20 }).should.have.properties({ b: 20 });\n   */\n  Assertion.add('properties', function(names) {\n    var values = {};\n    if (arguments.length > 1) {\n      names = aSlice.call(arguments);\n    } else if (!Array.isArray(names)) {\n      if (typeof names == 'string' || typeof names == 'symbol') {\n        names = [names];\n      } else {\n        values = names;\n        names = Object.keys(names);\n      }\n    }\n\n    var obj = Object(this.obj), missingProperties = [];\n\n    //just enumerate properties and check if they all present\n    names.forEach(function(name) {\n      if (!(name in obj)) {\n        missingProperties.push(formatProp(name));\n      }\n    });\n\n    var props = missingProperties;\n    if (props.length === 0) {\n      props = names.map(formatProp);\n    } else if (this.anyOne) {\n      props = names.filter(function(name) {\n        return missingProperties.indexOf(formatProp(name)) < 0;\n      }).map(formatProp);\n    }\n\n    var operator = (props.length === 1 ?\n        'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');\n\n    this.params = {obj: this.obj, operator: operator};\n\n    //check that all properties presented\n    //or if we request one of them that at least one them presented\n    this.assert(missingProperties.length === 0 || (this.anyOne && missingProperties.length != names.length));\n\n    // check if values in object matched expected\n    var valueCheckNames = Object.keys(values);\n    if (valueCheckNames.length) {\n      var wrongValues = [];\n      props = [];\n\n      // now check values, as there we have all properties\n      valueCheckNames.forEach(function(name) {\n        var value = values[name];\n        if (eql(obj[name], value).length !== 0) {\n          wrongValues.push(formatProp(name) + ' of ' + i(value) + ' (got ' + i(obj[name]) + ')');\n        } else {\n          props.push(formatProp(name) + ' of ' + i(value));\n        }\n      });\n\n      if ((wrongValues.length !== 0 && !this.anyOne) || (this.anyOne && props.length === 0)) {\n        props = wrongValues;\n      }\n\n      operator = (props.length === 1 ?\n        'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');\n\n      this.params = {obj: this.obj, operator: operator};\n\n      //if there is no not matched values\n      //or there is at least one matched\n      this.assert(wrongValues.length === 0 || (this.anyOne && wrongValues.length != valueCheckNames.length));\n    }\n  });\n\n  /**\n   * Asserts given object has property `length` with given value `n`\n   *\n   * @name length\n   * @alias Assertion#lengthOf\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {number} n Expected length\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * [1, 2].should.have.length(2);\n   */\n  Assertion.add('length', function(n, description) {\n    this.have.property('length', n, description);\n  });\n\n  Assertion.alias('length', 'lengthOf');\n\n  /**\n   * Asserts given object has own property. **On success it change given object to be value of property**.\n   *\n   * @name ownProperty\n   * @alias Assertion#hasOwnProperty\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {string} name Name of property\n   * @param {string} [description] Optional message\n   * @example\n   *\n   * ({ a: 10 }).should.have.ownProperty('a');\n   */\n  Assertion.add('ownProperty', function(name, description) {\n    name = convertPropertyName(name);\n    this.params = {\n      actual: this.obj,\n      operator: 'to have own property ' + formatProp(name),\n      message: description\n    };\n\n    this.assert(shouldUtil.hasOwnProperty(this.obj, name));\n\n    this.obj = this.obj[name];\n  });\n\n  Assertion.alias('ownProperty', 'hasOwnProperty');\n\n  /**\n   * Asserts given object is empty. For strings, arrays and arguments it checks .length property, for objects it checks keys.\n   *\n   * @name empty\n   * @memberOf Assertion\n   * @category assertion property\n   * @example\n   *\n   * ''.should.be.empty();\n   * [].should.be.empty();\n   * ({}).should.be.empty();\n   */\n  Assertion.add('empty', function() {\n    this.params = {operator: 'to be empty'};\n    this.assert(shouldTypeAdaptors.isEmpty(this.obj));\n  }, true);\n\n  /**\n   * Asserts given object has such keys. Compared to `properties`, `keys` does not accept Object as a argument.\n   * When calling via .key current object in assertion changed to value of this key\n   *\n   * @name keys\n   * @alias Assertion#key\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {...*} keys Keys to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.keys('a');\n   * ({ a: 10, b: 20 }).should.have.keys('a', 'b');\n   * (new Map([[1, 2]])).should.have.key(1);\n   *\n   * json.should.have.only.keys('type', 'version')\n   */\n  Assertion.add('keys', function(keys) {\n    keys = aSlice.call(arguments);\n\n    var obj = Object(this.obj);\n\n    // first check if some keys are missing\n    var missingKeys = keys.filter(function(key) {\n      return !shouldTypeAdaptors.has(obj, key);\n    });\n\n    var verb = 'to have ' + (this.onlyThis ? 'only ': '') + (keys.length === 1 ? 'key ' : 'keys ');\n\n    this.params = {operator: verb + keys.join(', ')};\n\n    if (missingKeys.length > 0) {\n      this.params.operator += '\\n\\tmissing keys: ' + missingKeys.join(', ');\n    }\n\n    this.assert(missingKeys.length === 0);\n\n    if (this.onlyThis) {\n      obj.should.have.size(keys.length);\n    }\n  });\n\n\n  Assertion.add('key', function(key) {\n    this.have.keys(key);\n    this.obj = shouldTypeAdaptors.get(this.obj, key);\n  });\n\n  /**\n   * Asserts given object has such value for given key\n   *\n   * @name value\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {*} key Key to check\n   * @param {*} value Value to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.value('a', 10);\n   * (new Map([[1, 2]])).should.have.value(1, 2);\n   */\n  Assertion.add('value', function(key, value) {\n    this.have.key(key).which.is.eql(value);\n  });\n\n  /**\n   * Asserts given object has such size.\n   *\n   * @name size\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {number} s Size to check\n   * @example\n   *\n   * ({ a: 10 }).should.have.size(1);\n   * (new Map([[1, 2]])).should.have.size(1);\n   */\n  Assertion.add('size', function(s) {\n    this.params = { operator: 'to have size ' + s };\n    shouldTypeAdaptors.size(this.obj).should.be.exactly(s);\n  });\n\n  /**\n   * Asserts given object has nested property in depth by path. **On success it change given object to be value of final property**.\n   *\n   * @name propertyByPath\n   * @memberOf Assertion\n   * @category assertion property\n   * @param {Array|...string} properties Properties path to search\n   * @example\n   *\n   * ({ a: {b: 10}}).should.have.propertyByPath('a', 'b').eql(10);\n   */\n  Assertion.add('propertyByPath', function(properties) {\n    properties = aSlice.call(arguments);\n\n    var allProps = properties.map(formatProp);\n\n    properties = properties.map(convertPropertyName);\n\n    var obj = should(Object(this.obj));\n\n    var foundProperties = [];\n\n    var currentProperty;\n    while (properties.length) {\n      currentProperty = properties.shift();\n      this.params = {operator: 'to have property by path ' + allProps.join(', ') + ' - failed on ' + formatProp(currentProperty)};\n      obj = obj.have.property(currentProperty);\n      foundProperties.push(currentProperty);\n    }\n\n    this.params = {obj: this.obj, operator: 'to have property by path ' + allProps.join(', ')};\n\n    this.obj = obj.obj;\n  });\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\nvar errorAssertions = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Assert given function throws error with such message.\n   *\n   * @name throw\n   * @memberOf Assertion\n   * @category assertion errors\n   * @alias Assertion#throwError\n   * @param {string|RegExp|Function|Object|GeneratorFunction|GeneratorObject} [message] Message to match or properties\n   * @param {Object} [properties] Optional properties that will be matched to thrown error\n   * @example\n   *\n   * (function(){ throw new Error('fail') }).should.throw();\n   * (function(){ throw new Error('fail') }).should.throw('fail');\n   * (function(){ throw new Error('fail') }).should.throw(/fail/);\n   *\n   * (function(){ throw new Error('fail') }).should.throw(Error);\n   * var error = new Error();\n   * error.a = 10;\n   * (function(){ throw error; }).should.throw(Error, { a: 10 });\n   * (function(){ throw error; }).should.throw({ a: 10 });\n   * (function*() {\n   *   yield throwError();\n   * }).should.throw();\n   */\n  Assertion.add('throw', function(message, properties) {\n    var fn = this.obj;\n    var err = {};\n    var errorInfo = '';\n    var thrown = false;\n\n    if (shouldUtil.isGeneratorFunction(fn)) {\n      return should(fn()).throw(message, properties);\n    } else if (shouldUtil.isIterator(fn)) {\n      return should(fn.next.bind(fn)).throw(message, properties);\n    }\n\n    this.is.a.Function();\n\n    var errorMatched = true;\n\n    try {\n      fn();\n    } catch (e) {\n      thrown = true;\n      err = e;\n    }\n\n    if (thrown) {\n      if (message) {\n        if ('string' == typeof message) {\n          errorMatched = message == err.message;\n        } else if (message instanceof RegExp) {\n          errorMatched = message.test(err.message);\n        } else if ('function' == typeof message) {\n          errorMatched = err instanceof message;\n        } else if (null != message) {\n          try {\n            should(err).match(message);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n\n        if (!errorMatched) {\n          if ('string' == typeof message || message instanceof RegExp) {\n            errorInfo = \" with a message matching \" + i(message) + \", but got '\" + err.message + \"'\";\n          } else if ('function' == typeof message) {\n            errorInfo = \" of type \" + functionName(message) + \", but got \" + functionName(err.constructor);\n          }\n        } else if ('function' == typeof message && properties) {\n          try {\n            should(err).match(properties);\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              errorInfo = \": \" + e.message;\n              errorMatched = false;\n            } else {\n              throw e;\n            }\n          }\n        }\n      } else {\n        errorInfo = \" (got \" + i(err) + \")\";\n      }\n    }\n\n    this.params = { operator: 'to throw exception' + errorInfo };\n\n    this.assert(thrown);\n    this.assert(errorMatched);\n  });\n\n  Assertion.alias('throw', 'throwError');\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n\nvar matchingAssertions = function(should, Assertion) {\n  var i = should.format;\n\n  /**\n   * Asserts if given object match `other` object, using some assumptions:\n   * First object matched if they are equal,\n   * If `other` is a regexp and given object is a string check on matching with regexp\n   * If `other` is a regexp and given object is an array check if all elements matched regexp\n   * If `other` is a regexp and given object is an object check values on matching regexp\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n   * If `other` is an object check if the same keys matched with above rules\n   * All other cases failed.\n   *\n   * Usually it is right idea to add pre type assertions, like `.String()` or `.Object()` to be sure assertions will do what you are expecting.\n   * Object iteration happen by keys (properties with enumerable: true), thus some objects can cause small pain. Typical example is js\n   * Error - it by default has 2 properties `name` and `message`, but they both non-enumerable. In this case make sure you specify checking props (see examples).\n   *\n   * @name match\n   * @memberOf Assertion\n   * @category assertion matching\n   * @param {*} other Object to match\n   * @param {string} [description] Optional message\n   * @example\n   * 'foobar'.should.match(/^foo/);\n   * 'foobar'.should.not.match(/^bar/);\n   *\n   * ({ a: 'foo', c: 'barfoo' }).should.match(/foo$/);\n   *\n   * ['a', 'b', 'c'].should.match(/[a-z]/);\n   *\n   * (5).should.not.match(function(n) {\n   *   return n < 0;\n   * });\n   * (5).should.not.match(function(it) {\n   *    it.should.be.an.Array();\n   * });\n   * ({ a: 10, b: 'abc', c: { d: 10 }, d: 0 }).should\n   * .match({ a: 10, b: /c$/, c: function(it) {\n   *    return it.should.have.property('d', 10);\n   * }});\n   *\n   * [10, 'abc', { d: 10 }, 0].should\n   * .match({ '0': 10, '1': /c$/, '2': function(it) {\n   *    return it.should.have.property('d', 10);\n   * }});\n   *\n   * var myString = 'abc';\n   *\n   * myString.should.be.a.String().and.match(/abc/);\n   *\n   * myString = {};\n   *\n   * myString.should.match(/abc/); //yes this will pass\n   * //better to do\n   * myString.should.be.an.Object().and.not.empty().and.match(/abc/);//fixed\n   *\n   * (new Error('boom')).should.match(/abc/);//passed because no keys\n   * (new Error('boom')).should.not.match({ message: /abc/ });//check specified property\n   */\n  Assertion.add('match', function(other, description) {\n    this.params = {operator: 'to match ' + i(other), message: description};\n\n    if (eql(this.obj, other).length !== 0) {\n      if (other instanceof RegExp) { // something - regex\n\n        if (typeof this.obj == 'string') {\n\n          this.assert(other.exec(this.obj));\n        } else if (null != this.obj && typeof this.obj == 'object') {\n\n          var notMatchedProps = [], matchedProps = [];\n          shouldTypeAdaptors.forEach(this.obj, function(value, name) {\n            if (other.exec(value)) {\n              matchedProps.push(formatProp(name));\n            } else {\n              notMatchedProps.push(formatProp(name) + ' (' + i(value) + ')');\n            }\n          }, this);\n\n          if (notMatchedProps.length) {\n            this.params.operator += '\\n    not matched properties: ' + notMatchedProps.join(', ');\n          }\n          if (matchedProps.length) {\n            this.params.operator += '\\n    matched properties: ' + matchedProps.join(', ');\n          }\n\n          this.assert(notMatchedProps.length === 0);\n        } // should we try to convert to String and exec?\n        else {\n          this.assert(false);\n        }\n      } else if (typeof other == 'function') {\n        var res;\n\n        res = other(this.obj);\n\n        //if we throw exception ok - it is used .should inside\n        if (typeof res == 'boolean') {\n          this.assert(res); // if it is just boolean function assert on it\n        }\n      } else if (other != null && this.obj != null && typeof other == 'object' && typeof this.obj == 'object') { // try to match properties (for Object and Array)\n        notMatchedProps = [];\n        matchedProps = [];\n\n        shouldTypeAdaptors.forEach(other, function(value, key) {\n          try {\n            should(this.obj).have.property(key).which.match(value);\n            matchedProps.push(formatProp(key));\n          } catch (e) {\n            if (e instanceof should.AssertionError) {\n              notMatchedProps.push(formatProp(key) + ' (' + i(this.obj[key]) + ')');\n            } else {\n              throw e;\n            }\n          }\n        }, this);\n\n        if (notMatchedProps.length) {\n          this.params.operator += '\\n    not matched properties: ' + notMatchedProps.join(', ');\n        }\n        if (matchedProps.length) {\n          this.params.operator += '\\n    matched properties: ' + matchedProps.join(', ');\n        }\n\n        this.assert(notMatchedProps.length === 0);\n      } else {\n        this.assert(false);\n      }\n    }\n  });\n\n  /**\n   * Asserts if given object values or array elements all match `other` object, using some assumptions:\n   * First object matched if they are equal,\n   * If `other` is a regexp - matching with regexp\n   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n   * All other cases check if this `other` equal to each element\n   *\n   * @name matchEach\n   * @memberOf Assertion\n   * @category assertion matching\n   * @alias Assertion#matchEvery\n   * @param {*} other Object to match\n   * @param {string} [description] Optional message\n   * @example\n   * [ 'a', 'b', 'c'].should.matchEach(/\\w+/);\n   * [ 'a', 'a', 'a'].should.matchEach('a');\n   *\n   * [ 'a', 'a', 'a'].should.matchEach(function(value) { value.should.be.eql('a') });\n   *\n   * { a: 'a', b: 'a', c: 'a' }.should.matchEach(function(value) { value.should.be.eql('a') });\n   */\n  Assertion.add('matchEach', function(other, description) {\n    this.params = {operator: 'to match each ' + i(other), message: description};\n\n    shouldTypeAdaptors.forEach(this.obj, function(value) {\n      should(value).match(other);\n    }, this);\n  });\n\n  /**\n  * Asserts if any of given object values or array elements match `other` object, using some assumptions:\n  * First object matched if they are equal,\n  * If `other` is a regexp - matching with regexp\n  * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched\n  * All other cases check if this `other` equal to each element\n  *\n  * @name matchAny\n  * @memberOf Assertion\n  * @category assertion matching\n  * @param {*} other Object to match\n  * @alias Assertion#matchSome\n  * @param {string} [description] Optional message\n  * @example\n  * [ 'a', 'b', 'c'].should.matchAny(/\\w+/);\n  * [ 'a', 'b', 'c'].should.matchAny('a');\n  *\n  * [ 'a', 'b', 'c'].should.matchAny(function(value) { value.should.be.eql('a') });\n  *\n  * { a: 'a', b: 'b', c: 'c' }.should.matchAny(function(value) { value.should.be.eql('a') });\n  */\n  Assertion.add('matchAny', function(other, description) {\n    this.params = {operator: 'to match any ' + i(other), message: description};\n\n    this.assert(shouldTypeAdaptors.some(this.obj, function(value) {\n      try {\n        should(value).match(other);\n        return true;\n      } catch (e) {\n        if (e instanceof should.AssertionError) {\n          // Caught an AssertionError, return false to the iterator\n          return false;\n        }\n        throw e;\n      }\n    }));\n  });\n\n  Assertion.alias('matchAny', 'matchSome');\n  Assertion.alias('matchEach', 'matchEvery');\n};\n\n/*\n * should.js - assertion library\n * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>\n * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>\n * MIT Licensed\n */\n/**\n * Our function should\n *\n * @param {*} obj Object to assert\n * @returns {should.Assertion} Returns new Assertion for beginning assertion chain\n * @example\n *\n * var should = require('should');\n * should('abc').be.a.String();\n */\nfunction should(obj) {\n  return (new Assertion(obj));\n}\n\nshould.AssertionError = AssertionError;\nshould.Assertion = Assertion;\n\n// exposing modules dirty way\nshould.modules = {\n  format: sformat,\n  type: getType,\n  equal: eql\n};\nshould.format = format;\n\n/**\n * Object with configuration.\n * It contains such properties:\n * * `checkProtoEql` boolean - Affect if `.eql` will check objects prototypes\n * * `plusZeroAndMinusZeroEqual` boolean - Affect if `.eql` will treat +0 and -0 as equal\n * Also it can contain options for should-format.\n *\n * @type {Object}\n * @memberOf should\n * @static\n * @example\n *\n * var a = { a: 10 }, b = Object.create(null);\n * b.a = 10;\n *\n * a.should.be.eql(b);\n * //not throws\n *\n * should.config.checkProtoEql = true;\n * a.should.be.eql(b);\n * //throws AssertionError: expected { a: 10 } to equal { a: 10 } (because A and B have different prototypes)\n */\nshould.config = config;\n\n/**\n * Allow to extend given prototype with should property using given name. This getter will **unwrap** all standard wrappers like `Number`, `Boolean`, `String`.\n * Using `should(obj)` is the equivalent of using `obj.should` with known issues (like nulls and method calls etc).\n *\n * To add new assertions, need to use Assertion.add method.\n *\n * @param {string} [propertyName] Name of property to add. Default is `'should'`.\n * @param {Object} [proto] Prototype to extend with. Default is `Object.prototype`.\n * @memberOf should\n * @returns {{ name: string, descriptor: Object, proto: Object }} Descriptor enough to return all back\n * @static\n * @example\n *\n * var prev = should.extend('must', Object.prototype);\n *\n * 'abc'.must.startWith('a');\n *\n * var should = should.noConflict(prev);\n * should.not.exist(Object.prototype.must);\n */\nshould.extend = function(propertyName, proto) {\n  propertyName = propertyName || 'should';\n  proto = proto || Object.prototype;\n\n  var prevDescriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n\n  Object.defineProperty(proto, propertyName, {\n    set: function() {\n    },\n    get: function() {\n      return should(isWrapperType(this) ? this.valueOf() : this);\n    },\n    configurable: true\n  });\n\n  return { name: propertyName, descriptor: prevDescriptor, proto: proto };\n};\n\n/**\n * Delete previous extension. If `desc` missing it will remove default extension.\n *\n * @param {{ name: string, descriptor: Object, proto: Object }} [desc] Returned from `should.extend` object\n * @memberOf should\n * @returns {Function} Returns should function\n * @static\n * @example\n *\n * var should = require('should').noConflict();\n *\n * should(Object.prototype).not.have.property('should');\n *\n * var prev = should.extend('must', Object.prototype);\n * 'abc'.must.startWith('a');\n * should.noConflict(prev);\n *\n * should(Object.prototype).not.have.property('must');\n */\nshould.noConflict = function(desc) {\n  desc = desc || should._prevShould;\n\n  if (desc) {\n    delete desc.proto[desc.name];\n\n    if (desc.descriptor) {\n      Object.defineProperty(desc.proto, desc.name, desc.descriptor);\n    }\n  }\n  return should;\n};\n\n/**\n * Simple utility function for a bit more easier should assertion extension\n * @param {Function} f So called plugin function. It should accept 2 arguments: `should` function and `Assertion` constructor\n * @memberOf should\n * @returns {Function} Returns `should` function\n * @static\n * @example\n *\n * should.use(function(should, Assertion) {\n *   Assertion.add('asset', function() {\n *      this.params = { operator: 'to be asset' };\n *\n *      this.obj.should.have.property('id').which.is.a.Number();\n *      this.obj.should.have.property('path');\n *  })\n * })\n */\nshould.use = function(f) {\n  f(should, should.Assertion);\n  return this;\n};\n\nshould\n  .use(assertExtensions)\n  .use(chainAssertions)\n  .use(booleanAssertions)\n  .use(numberAssertions)\n  .use(equalityAssertions)\n  .use(typeAssertions)\n  .use(stringAssertions)\n  .use(propertyAssertions)\n  .use(errorAssertions)\n  .use(matchingAssertions)\n  .use(containAssertions)\n  .use(promiseAssertions);\n\nmodule.exports = should;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/should/cjs/should.js\n// module id = 5\n// module chunks = 0","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/buffer/index.js\n// module id = 6\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 7\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/base64-js/index.js\n// module id = 8\n// module chunks = 0","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ieee754/index.js\n// module id = 9\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/isarray/index.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar t = _interopDefault(require('should-type'));\n\nfunction format(msg) {\n  var args = arguments;\n  for (var i = 1, l = args.length; i < l; i++) {\n    msg = msg.replace(/%s/, args[i]);\n  }\n  return msg;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction EqualityFail(a, b, reason, path) {\n  this.a = a;\n  this.b = b;\n  this.reason = reason;\n  this.path = path;\n}\n\nfunction typeToString(tp) {\n  return tp.type + (tp.cls ? '(' + tp.cls + (tp.sub ? ' ' + tp.sub : '') + ')' : '');\n}\n\nvar  PLUS_0_AND_MINUS_0 = '+0 is not equal to -0';\nvar  DIFFERENT_TYPES = 'A has type %s and B has type %s';\nvar  EQUALITY = 'A is not equal to B';\nvar  EQUALITY_PROTOTYPE = 'A and B have different prototypes';\nvar  WRAPPED_VALUE = 'A wrapped value is not equal to B wrapped value';\nvar  FUNCTION_SOURCES = 'function A is not equal to B by source code value (via .toString call)';\nvar  MISSING_KEY = '%s has no key %s';\nvar  SET_MAP_MISSING_KEY = 'Set/Map missing key %s';\n\n\nvar DEFAULT_OPTIONS = {\n  checkProtoEql: true,\n  checkSubType: true,\n  plusZeroAndMinusZeroEqual: true,\n  collectAllFails: false\n};\n\nfunction setBooleanDefault(property, obj, opts, defaults) {\n  obj[property] = typeof opts[property] !== 'boolean' ? defaults[property] : opts[property];\n}\n\nvar METHOD_PREFIX = '_check_';\n\nfunction EQ(opts, a, b, path) {\n  opts = opts || {};\n\n  setBooleanDefault('checkProtoEql', this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault('plusZeroAndMinusZeroEqual', this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault('checkSubType', this, opts, DEFAULT_OPTIONS);\n  setBooleanDefault('collectAllFails', this, opts, DEFAULT_OPTIONS);\n\n  this.a = a;\n  this.b = b;\n\n  this._meet = opts._meet || [];\n\n  this.fails = opts.fails || [];\n\n  this.path = path || [];\n}\n\nfunction ShortcutError(fail) {\n  this.name = 'ShortcutError';\n  this.message = 'fail fast';\n  this.fail = fail;\n}\n\nShortcutError.prototype = Object.create(Error.prototype);\n\nEQ.checkStrictEquality = function(a, b) {\n  this.collectFail(a !== b, EQUALITY);\n};\n\nEQ.add = function add(type, cls, sub, f) {\n  var args = Array.prototype.slice.call(arguments);\n  f = args.pop();\n  EQ.prototype[METHOD_PREFIX + args.join('_')] = f;\n};\n\nEQ.prototype = {\n  check: function() {\n    try {\n      this.check0();\n    } catch (e) {\n      if (e instanceof ShortcutError) {\n        return [e.fail];\n      }\n      throw e;\n    }\n    return this.fails;\n  },\n\n  check0: function() {\n    var a = this.a;\n    var b = this.b;\n\n    // equal a and b exit early\n    if (a === b) {\n      // check for +0 !== -0;\n      return this.collectFail(a === 0 && (1 / a !== 1 / b) && !this.plusZeroAndMinusZeroEqual, PLUS_0_AND_MINUS_0);\n    }\n\n    var typeA = t(a);\n    var typeB = t(b);\n\n    // if objects has different types they are not equal\n    if (typeA.type !== typeB.type || typeA.cls !== typeB.cls || typeA.sub !== typeB.sub) {\n      return this.collectFail(true, format(DIFFERENT_TYPES, typeToString(typeA), typeToString(typeB)));\n    }\n\n    // as types the same checks type specific things\n    var name1 = typeA.type, name2 = typeA.type;\n    if (typeA.cls) {\n      name1 += '_' + typeA.cls;\n      name2 += '_' + typeA.cls;\n    }\n    if (typeA.sub) {\n      name2 += '_' + typeA.sub;\n    }\n\n    var f = this[METHOD_PREFIX + name2] || this[METHOD_PREFIX + name1] || this[METHOD_PREFIX + typeA.type] || this.defaultCheck;\n\n    f.call(this, this.a, this.b);\n  },\n\n  collectFail: function(comparison, reason, showReason) {\n    if (comparison) {\n      var res = new EqualityFail(this.a, this.b, reason, this.path);\n      res.showReason = !!showReason;\n\n      this.fails.push(res);\n\n      if (!this.collectAllFails) {\n        throw new ShortcutError(res);\n      }\n    }\n  },\n\n  checkPlainObjectsEquality: function(a, b) {\n    // compare deep objects and arrays\n    // stacks contain references only\n    //\n    var meet = this._meet;\n    var m = this._meet.length;\n    while (m--) {\n      var st = meet[m];\n      if (st[0] === a && st[1] === b) {\n        return;\n      }\n    }\n\n    // add `a` and `b` to the stack of traversed objects\n    meet.push([a, b]);\n\n    // TODO maybe something else like getOwnPropertyNames\n    var key;\n    for (key in b) {\n      if (hasOwnProperty.call(b, key)) {\n        if (hasOwnProperty.call(a, key)) {\n          this.checkPropertyEquality(key);\n        } else {\n          this.collectFail(true, format(MISSING_KEY, 'A', key));\n        }\n      }\n    }\n\n    // ensure both objects have the same number of properties\n    for (key in a) {\n      if (hasOwnProperty.call(a, key)) {\n        this.collectFail(!hasOwnProperty.call(b, key), format(MISSING_KEY, 'B', key));\n      }\n    }\n\n    meet.pop();\n\n    if (this.checkProtoEql) {\n      //TODO should i check prototypes for === or use eq?\n      this.collectFail(Object.getPrototypeOf(a) !== Object.getPrototypeOf(b), EQUALITY_PROTOTYPE, true);\n    }\n\n  },\n\n  checkPropertyEquality: function(propertyName) {\n    var _eq = new EQ(this, this.a[propertyName], this.b[propertyName], this.path.concat([propertyName]));\n    _eq.check0();\n  },\n\n  defaultCheck: EQ.checkStrictEquality\n};\n\n\nEQ.add(t.NUMBER, function(a, b) {\n  this.collectFail((a !== a && b === b) || (b !== b && a === a) || (a !== b && a === a && b === b), EQUALITY);\n});\n\n[t.SYMBOL, t.BOOLEAN, t.STRING].forEach(function(tp) {\n  EQ.add(tp, EQ.checkStrictEquality);\n});\n\nEQ.add(t.FUNCTION, function(a, b) {\n  // functions are compared by their source code\n  this.collectFail(a.toString() !== b.toString(), FUNCTION_SOURCES);\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.REGEXP, function(a, b) {\n  // check regexp flags\n  var flags = ['source', 'global', 'multiline', 'lastIndex', 'ignoreCase', 'sticky', 'unicode'];\n  while (flags.length) {\n    this.checkPropertyEquality(flags.shift());\n  }\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.DATE, function(a, b) {\n  //check by timestamp only (using .valueOf)\n  this.collectFail(+a !== +b, EQUALITY);\n  // check user properties\n  this.checkPlainObjectsEquality(a, b);\n});\n\n[t.NUMBER, t.BOOLEAN, t.STRING].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    //primitive type wrappers\n    this.collectFail(a.valueOf() !== b.valueOf(), WRAPPED_VALUE);\n    // check user properties\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\nEQ.add(t.OBJECT, function(a, b) {\n  this.checkPlainObjectsEquality(a, b);\n});\n\n[t.ARRAY, t.ARGUMENTS, t.TYPED_ARRAY].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    this.checkPropertyEquality('length');\n\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\nEQ.add(t.OBJECT, t.ARRAY_BUFFER, function(a, b) {\n  this.checkPropertyEquality('byteLength');\n\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.ERROR, function(a, b) {\n  this.checkPropertyEquality('name');\n  this.checkPropertyEquality('message');\n\n  this.checkPlainObjectsEquality(a, b);\n});\n\nEQ.add(t.OBJECT, t.BUFFER, function(a) {\n  this.checkPropertyEquality('length');\n\n  var l = a.length;\n  while (l--) {\n    this.checkPropertyEquality(l);\n  }\n\n  //we do not check for user properties because\n  //node Buffer have some strange hidden properties\n});\n\n[t.MAP, t.SET, t.WEAK_MAP, t.WEAK_SET].forEach(function(tp) {\n  EQ.add(t.OBJECT, tp, function(a, b) {\n    this._meet.push([a, b]);\n\n    var iteratorA = a.entries();\n    for (var nextA = iteratorA.next(); !nextA.done; nextA = iteratorA.next()) {\n\n      var iteratorB = b.entries();\n      var keyFound = false;\n      for (var nextB = iteratorB.next(); !nextB.done; nextB = iteratorB.next()) {\n        // try to check keys first\n        var r = eq(nextA.value[0], nextB.value[0], { collectAllFails: false, _meet: this._meet });\n\n        if (r.length === 0) {\n          keyFound = true;\n\n          // check values also\n          eq(nextA.value[1], nextB.value[1], this);\n        }\n      }\n\n      if (!keyFound) {\n        // no such key at all\n        this.collectFail(true, format(SET_MAP_MISSING_KEY, nextA.value[0]));\n      }\n    }\n\n    this._meet.pop();\n\n    this.checkPlainObjectsEquality(a, b);\n  });\n});\n\n\nfunction eq(a, b, opts) {\n  return new EQ(opts, a, b).check();\n}\n\neq.EQ = EQ;\n\nmodule.exports = eq;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/should-equal/cjs/should-equal.js\n// module id = 11\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar t = _interopDefault(require('should-type'));\nvar shouldTypeAdaptors = require('should-type-adaptors');\n\nfunction looksLikeANumber(n) {\n  return !!n.match(/\\d+/);\n}\n\nfunction keyCompare(a, b) {\n  var aNum = looksLikeANumber(a);\n  var bNum = looksLikeANumber(b);\n  if (aNum && bNum) {\n    return 1*a - 1*b;\n  } else if (aNum && !bNum) {\n    return -1;\n  } else if (!aNum && bNum) {\n    return 1;\n  } else {\n    return a.localeCompare(b);\n  }\n}\n\nfunction genKeysFunc(f) {\n  return function(value) {\n    var k = f(value);\n    k.sort(keyCompare);\n    return k;\n  };\n}\n\nfunction Formatter(opts) {\n  opts = opts || {};\n\n  this.seen = [];\n\n  var keysFunc;\n  if (typeof opts.keysFunc === 'function') {\n    keysFunc = opts.keysFunc;\n  } else if (opts.keys === false) {\n    keysFunc = Object.getOwnPropertyNames;\n  } else {\n    keysFunc = Object.keys;\n  }\n\n  this.getKeys = genKeysFunc(keysFunc);\n\n  this.maxLineLength = typeof opts.maxLineLength === 'number' ? opts.maxLineLength : 60;\n  this.propSep = opts.propSep || ',';\n\n  this.isUTCdate = !!opts.isUTCdate;\n}\n\n\n\nFormatter.prototype = {\n  constructor: Formatter,\n\n  format: function(value) {\n    var tp = t(value);\n\n    if (this.alreadySeen(value)) {\n      return '[Circular]';\n    }\n\n    var tries = tp.toTryTypes();\n    var f = this.defaultFormat;\n    while (tries.length) {\n      var toTry = tries.shift();\n      var name = Formatter.formatterFunctionName(toTry);\n      if (this[name]) {\n        f = this[name];\n        break;\n      }\n    }\n    return f.call(this, value).trim();\n  },\n\n  defaultFormat: function(obj) {\n    return String(obj);\n  },\n\n  alreadySeen: function(value) {\n    return this.seen.indexOf(value) >= 0;\n  }\n\n};\n\nFormatter.addType = function addType(tp, f) {\n  Formatter.prototype[Formatter.formatterFunctionName(tp)] = f;\n};\n\nFormatter.formatterFunctionName = function formatterFunctionName(tp) {\n  return '_format_' + tp.toString('_');\n};\n\nvar EOL = '\\n';\n\nfunction indent(v, indentation) {\n  return v\n    .split(EOL)\n    .map(function(vv) {\n      return indentation + vv;\n    })\n    .join(EOL);\n}\n\nfunction pad(str, value, filler) {\n  str = String(str);\n  var isRight = false;\n\n  if (value < 0) {\n    isRight = true;\n    value = -value;\n  }\n\n  if (str.length < value) {\n    var padding = new Array(value - str.length + 1).join(filler);\n    return isRight ? str + padding : padding + str;\n  } else {\n    return str;\n  }\n}\n\nfunction pad0(str, value) {\n  return pad(str, value, '0');\n}\n\nvar functionNameRE = /^\\s*function\\s*(\\S*)\\s*\\(/;\n\nfunction functionName(f) {\n  if (f.name) {\n    return f.name;\n  }\n  var matches = f.toString().match(functionNameRE);\n  if (matches === null) {\n    // `functionNameRE` doesn't match arrow functions.\n    return '';\n  }\n  var name = matches[1];\n  return name;\n}\n\nfunction constructorName(obj) {\n  while (obj) {\n    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined &&  typeof descriptor.value === 'function') {\n      var name = functionName(descriptor.value);\n      if (name !== '') {\n        return name;\n      }\n    }\n\n    obj = Object.getPrototypeOf(obj);\n  }\n}\n\nvar INDENT = '  ';\n\nfunction addSpaces(str) {\n  return indent(str, INDENT);\n}\n\nfunction typeAdaptorForEachFormat(obj, opts) {\n  opts = opts || {};\n  var filterKey = opts.filterKey || function() { return true; };\n\n  var formatKey = opts.formatKey || this.format;\n  var formatValue = opts.formatValue || this.format;\n\n  var keyValueSep = typeof opts.keyValueSep !== 'undefined' ? opts.keyValueSep : ': ';\n\n  this.seen.push(obj);\n\n  var formatLength = 0;\n  var pairs = [];\n\n  shouldTypeAdaptors.forEach(obj, function(value, key) {\n    if (!filterKey(key)) {\n      return;\n    }\n\n    var formattedKey = formatKey.call(this, key);\n    var formattedValue = formatValue.call(this, value, key);\n\n    var pair = formattedKey ? (formattedKey + keyValueSep + formattedValue) : formattedValue;\n\n    formatLength += pair.length;\n    pairs.push(pair);\n  }, this);\n\n  this.seen.pop();\n\n  (opts.additionalKeys || []).forEach(function(keyValue) {\n    var pair = keyValue[0] + keyValueSep + this.format(keyValue[1]);\n    formatLength += pair.length;\n    pairs.push(pair);\n  }, this);\n\n  var prefix = opts.prefix || constructorName(obj) || '';\n  if (prefix.length > 0) {\n    prefix += ' ';\n  }\n\n  var lbracket, rbracket;\n  if (Array.isArray(opts.brackets)) {\n    lbracket = opts.brackets[0];\n    rbracket = opts.brackets[1];\n  } else {\n    lbracket = '{';\n    rbracket = '}';\n  }\n\n  var rootValue = opts.value || '';\n\n  if (pairs.length === 0) {\n    return rootValue || (prefix + lbracket + rbracket);\n  }\n\n  if (formatLength <= this.maxLineLength) {\n    return prefix + lbracket + ' ' + (rootValue ? rootValue + ' ' : '') + pairs.join(this.propSep + ' ') + ' ' + rbracket;\n  } else {\n    return prefix + lbracket + '\\n' + (rootValue ? '  ' + rootValue + '\\n' : '') + pairs.map(addSpaces).join(this.propSep + '\\n') + '\\n' + rbracket;\n  }\n}\n\nfunction formatPlainObjectKey(key) {\n  return typeof key === 'string' && key.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*$/) ? key : this.format(key);\n}\n\nfunction getPropertyDescriptor(obj, key) {\n  var desc;\n  try {\n    desc = Object.getOwnPropertyDescriptor(obj, key) || { value: obj[key] };\n  } catch (e) {\n    desc = { value: e };\n  }\n  return desc;\n}\n\nfunction formatPlainObjectValue(obj, key) {\n  var desc = getPropertyDescriptor(obj, key);\n  if (desc.get && desc.set) {\n    return '[Getter/Setter]';\n  }\n  if (desc.get) {\n    return '[Getter]';\n  }\n  if (desc.set) {\n    return '[Setter]';\n  }\n\n  return this.format(desc.value);\n}\n\nfunction formatPlainObject(obj, opts) {\n  opts = opts || {};\n  opts.keyValueSep = ': ';\n  opts.formatKey = opts.formatKey || formatPlainObjectKey;\n  opts.formatValue = opts.formatValue || function(value, key) {\n    return formatPlainObjectValue.call(this, obj, key);\n  };\n  return typeAdaptorForEachFormat.call(this, obj, opts);\n}\n\nfunction formatWrapper1(value) {\n  return formatPlainObject.call(this, value, {\n    additionalKeys: [['[[PrimitiveValue]]', value.valueOf()]]\n  });\n}\n\n\nfunction formatWrapper2(value) {\n  var realValue = value.valueOf();\n\n  return formatPlainObject.call(this, value, {\n    filterKey: function(key) {\n      //skip useless indexed properties\n      return !(key.match(/\\d+/) && parseInt(key, 10) < realValue.length);\n    },\n    additionalKeys: [['[[PrimitiveValue]]', realValue]]\n  });\n}\n\nfunction formatRegExp(value) {\n  return formatPlainObject.call(this, value, {\n    value: String(value)\n  });\n}\n\nfunction formatFunction(value) {\n  return formatPlainObject.call(this, value, {\n    prefix: 'Function',\n    additionalKeys: [['name', functionName(value)]]\n  });\n}\n\nfunction formatArray(value) {\n  return formatPlainObject.call(this, value, {\n    formatKey: function(key) {\n      if (!key.match(/\\d+/)) {\n        return formatPlainObjectKey.call(this, key);\n      }\n    },\n    brackets: ['[', ']']\n  });\n}\n\nfunction formatArguments(value) {\n  return formatPlainObject.call(this, value, {\n    formatKey: function(key) {\n      if (!key.match(/\\d+/)) {\n        return formatPlainObjectKey.call(this, key);\n      }\n    },\n    brackets: ['[', ']'],\n    prefix: 'Arguments'\n  });\n}\n\nfunction _formatDate(value, isUTC) {\n  var prefix = isUTC ? 'UTC' : '';\n\n  var date = value['get' + prefix + 'FullYear']() +\n    '-' +\n    pad0(value['get' + prefix + 'Month']() + 1, 2) +\n    '-' +\n    pad0(value['get' + prefix + 'Date'](), 2);\n\n  var time = pad0(value['get' + prefix + 'Hours'](), 2) +\n    ':' +\n    pad0(value['get' + prefix + 'Minutes'](), 2) +\n    ':' +\n    pad0(value['get' + prefix + 'Seconds'](), 2) +\n    '.' +\n    pad0(value['get' + prefix + 'Milliseconds'](), 3);\n\n  var to = value.getTimezoneOffset();\n  var absTo = Math.abs(to);\n  var hours = Math.floor(absTo / 60);\n  var minutes = absTo - hours * 60;\n  var tzFormat = (to < 0 ? '+' : '-') + pad0(hours, 2) + pad0(minutes, 2);\n\n  return date + ' ' + time + (isUTC ? '' : ' ' + tzFormat);\n}\n\nfunction formatDate(value) {\n  return formatPlainObject.call(this, value, { value: _formatDate(value, this.isUTCdate) });\n}\n\nfunction formatError(value) {\n  return formatPlainObject.call(this, value, {\n    prefix: value.name,\n    additionalKeys: [['message', value.message]]\n  });\n}\n\nfunction generateFormatForNumberArray(lengthProp, name, padding) {\n  return function(value) {\n    var max = this.byteArrayMaxLength || 50;\n    var length = value[lengthProp];\n    var formattedValues = [];\n    var len = 0;\n    for (var i = 0; i < max && i < length; i++) {\n      var b = value[i] || 0;\n      var v = pad0(b.toString(16), padding);\n      len += v.length;\n      formattedValues.push(v);\n    }\n    var prefix = value.constructor.name || name || '';\n    if (prefix) {\n      prefix += ' ';\n    }\n\n    if (formattedValues.length === 0) {\n      return prefix + '[]';\n    }\n\n    if (len <= this.maxLineLength) {\n      return prefix + '[ ' + formattedValues.join(this.propSep + ' ') + ' ' + ']';\n    } else {\n      return prefix + '[\\n' + formattedValues.map(addSpaces).join(this.propSep + '\\n') + '\\n' + ']';\n    }\n  };\n}\n\nfunction formatMap(obj) {\n  return typeAdaptorForEachFormat.call(this, obj, {\n    keyValueSep: ' => '\n  });\n}\n\nfunction formatSet(obj) {\n  return typeAdaptorForEachFormat.call(this, obj, {\n    keyValueSep: '',\n    formatKey: function() { return ''; }\n  });\n}\n\nfunction genSimdVectorFormat(constructorName, length) {\n  return function(value) {\n    var Constructor = value.constructor;\n    var extractLane = Constructor.extractLane;\n\n    var len = 0;\n    var props = [];\n\n    for (var i = 0; i < length; i ++) {\n      var key = this.format(extractLane(value, i));\n      len += key.length;\n      props.push(key);\n    }\n\n    if (len <= this.maxLineLength) {\n      return constructorName + ' [ ' + props.join(this.propSep + ' ') + ' ]';\n    } else {\n      return constructorName + ' [\\n' + props.map(addSpaces).join(this.propSep + '\\n') + '\\n' + ']';\n    }\n  };\n}\n\nfunction defaultFormat(value, opts) {\n  return new Formatter(opts).format(value);\n}\n\ndefaultFormat.Formatter = Formatter;\ndefaultFormat.addSpaces = addSpaces;\ndefaultFormat.pad0 = pad0;\ndefaultFormat.functionName = functionName;\ndefaultFormat.constructorName = constructorName;\ndefaultFormat.formatPlainObjectKey = formatPlainObjectKey;\ndefaultFormat.formatPlainObject = formatPlainObject;\ndefaultFormat.typeAdaptorForEachFormat = typeAdaptorForEachFormat;\n// adding primitive types\nFormatter.addType(new t.Type(t.UNDEFINED), function() {\n  return 'undefined';\n});\nFormatter.addType(new t.Type(t.NULL), function() {\n  return 'null';\n});\nFormatter.addType(new t.Type(t.BOOLEAN), function(value) {\n  return value ? 'true': 'false';\n});\nFormatter.addType(new t.Type(t.SYMBOL), function(value) {\n  return value.toString();\n});\nFormatter.addType(new t.Type(t.NUMBER), function(value) {\n  if (value === 0 && 1 / value < 0) {\n    return '-0';\n  }\n  return String(value);\n});\n\nFormatter.addType(new t.Type(t.STRING), function(value) {\n  return '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n      .replace(/'/g, \"\\\\'\")\n      .replace(/\\\\\"/g, '\"') + '\\'';\n});\n\nFormatter.addType(new t.Type(t.FUNCTION), formatFunction);\n\n// plain object\nFormatter.addType(new t.Type(t.OBJECT), formatPlainObject);\n\n// type wrappers\nFormatter.addType(new t.Type(t.OBJECT, t.NUMBER), formatWrapper1);\nFormatter.addType(new t.Type(t.OBJECT, t.BOOLEAN), formatWrapper1);\nFormatter.addType(new t.Type(t.OBJECT, t.STRING), formatWrapper2);\n\nFormatter.addType(new t.Type(t.OBJECT, t.REGEXP), formatRegExp);\nFormatter.addType(new t.Type(t.OBJECT, t.ARRAY), formatArray);\nFormatter.addType(new t.Type(t.OBJECT, t.ARGUMENTS), formatArguments);\nFormatter.addType(new t.Type(t.OBJECT, t.DATE), formatDate);\nFormatter.addType(new t.Type(t.OBJECT, t.ERROR), formatError);\nFormatter.addType(new t.Type(t.OBJECT, t.SET), formatSet);\nFormatter.addType(new t.Type(t.OBJECT, t.MAP), formatMap);\nFormatter.addType(new t.Type(t.OBJECT, t.WEAK_MAP), formatMap);\nFormatter.addType(new t.Type(t.OBJECT, t.WEAK_SET), formatSet);\n\nFormatter.addType(new t.Type(t.OBJECT, t.BUFFER), generateFormatForNumberArray('length', 'Buffer', 2));\n\nFormatter.addType(new t.Type(t.OBJECT, t.ARRAY_BUFFER), generateFormatForNumberArray('byteLength', 'ArrayBuffer', 2));\n\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int8'), generateFormatForNumberArray('length', 'Int8Array', 2));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint8'), generateFormatForNumberArray('length', 'Uint8Array', 2));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint8clamped'), generateFormatForNumberArray('length', 'Uint8ClampedArray', 2));\n\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int16'), generateFormatForNumberArray('length', 'Int16Array', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint16'), generateFormatForNumberArray('length', 'Uint16Array', 4));\n\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int32'), generateFormatForNumberArray('length', 'Int32Array', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint32'), generateFormatForNumberArray('length', 'Uint32Array', 8));\n\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool16x8'), genSimdVectorFormat('Bool16x8', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool32x4'), genSimdVectorFormat('Bool32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool8x16'), genSimdVectorFormat('Bool8x16', 16));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'float32x4'), genSimdVectorFormat('Float32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int16x8'), genSimdVectorFormat('Int16x8', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int32x4'), genSimdVectorFormat('Int32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int8x16'), genSimdVectorFormat('Int8x16', 16));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint16x8'), genSimdVectorFormat('Uint16x8', 8));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint32x4'), genSimdVectorFormat('Uint32x4', 4));\nFormatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint8x16'), genSimdVectorFormat('Uint8x16', 16));\n\n\nFormatter.addType(new t.Type(t.OBJECT, t.PROMISE), function() {\n  return '[Promise]';//TODO it could be nice to inspect its state and value\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.XHR), function() {\n  return '[XMLHttpRequest]';//TODO it could be nice to inspect its state\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT), function(value) {\n  return value.outerHTML;\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, '#text'), function(value) {\n  return value.nodeValue;\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, '#document'), function(value) {\n  return value.documentElement.outerHTML;\n});\n\nFormatter.addType(new t.Type(t.OBJECT, t.HOST), function() {\n  return '[Host]';\n});\n\nmodule.exports = defaultFormat;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/should-format/cjs/should-format.js\n// module id = 12\n// module chunks = 0","\"use strict\";\r\n\r\n/*;\r\n\t@module-license:\r\n\t\tThe MIT License (MIT)\r\n\t\t@mit-license\r\n\r\n\t\tCopyright (@c) 2017 Richeve Siodina Bebedor\r\n\t\t@email: richeve.bebedor@gmail.com\r\n\r\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy\r\n\t\tof this software and associated documentation files (the \"Software\"), to deal\r\n\t\tin the Software without restriction, including without limitation the rights\r\n\t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n\t\tcopies of the Software, and to permit persons to whom the Software is\r\n\t\tfurnished to do so, subject to the following conditions:\r\n\r\n\t\tThe above copyright notice and this permission notice shall be included in all\r\n\t\tcopies or substantial portions of the Software.\r\n\r\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n\t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n\t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n\t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n\t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n\t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n\t\tSOFTWARE.\r\n\t@end-module-license\r\n\r\n\t@module-configuration:\r\n\t\t{\r\n\t\t\t\"package\": \"nmde\",\r\n\t\t\t\"path\": \"nmde/nmde.js\",\r\n\t\t\t\"file\": \"nmde.js\",\r\n\t\t\t\"module\": \"nmde\",\r\n\t\t\t\"author\": \"Richeve S. Bebedor\",\r\n\t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\r\n\t\t\t\"contributors\": [\r\n\t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\",\r\n\t\t\t\t\"Vinse Vinalon <vinsevinalon@gmail.com>\"\r\n\t\t\t],\r\n\t\t\t\"repository\": \"https://github.com/volkovasystems/nmde.git\",\r\n\t\t\t\"test\": \"nmde-test.js\",\r\n\t\t\t\"global\": true\r\n\t\t}\r\n\t@end-module-configuration\r\n\r\n\t@module-documentation:\r\n\t\tGet string name property of entity.\r\n\t@end-module-documentation\r\n\r\n\t@include:\r\n\t\t{\r\n\t\t\t\"falzy\": \"falzy\",\r\n\t\t\t\"truly\": \"truly\"\r\n\t\t}\r\n\t@end-include\r\n*/\r\n\r\nconst falzy = require( \"falzy\" );\r\nconst truly = require( \"truly\" );\r\n\r\nconst EMPTY_NAME = \"\";\r\n\r\nconst nmde = function nmde( entity ){\r\n\t/*;\r\n\t\t@meta-configuration:\r\n\t\t\t{\r\n\t\t\t\t\"entity:required\": [\r\n\t\t\t\t\t\"function\",\r\n\t\t\t\t\t\"object\",\r\n\t\t\t\t\t\"*\"\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t@end-meta-configuration\r\n\t*/\r\n\r\n\tif( falzy( entity ) ){\r\n\t\treturn EMPTY_NAME;\r\n\t}\r\n\r\n\tif( truly( entity.name ) && typeof entity.name == \"string\" ){\r\n\t\treturn entity.name;\r\n\t}\r\n\r\n\treturn EMPTY_NAME;\r\n};\r\n\r\nmodule.exports = nmde;\r\n\n\n\n// WEBPACK FOOTER //\n// nmde.support.js","\"use strict\";\n\n/*;\n\t@module-license:\n\t\tThe MIT License (MIT)\n\t\t@mit-license\n\n\t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n\t\t@email: richeve.bebedor@gmail.com\n\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\t\tof this software and associated documentation files (the \"Software\"), to deal\n\t\tin the Software without restriction, including without limitation the rights\n\t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t\tcopies of the Software, and to permit persons to whom the Software is\n\t\tfurnished to do so, subject to the following conditions:\n\n\t\tThe above copyright notice and this permission notice shall be included in all\n\t\tcopies or substantial portions of the Software.\n\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\t\tSOFTWARE.\n\t@end-module-license\n\n\t@module-configuration:\n\t\t{\n\t\t\t\"package\": \"falzy\",\n\t\t\t\"path\": \"falzy/falzy.js\",\n\t\t\t\"file\": \"falzy.js\",\n\t\t\t\"module\": \"falzy\",\n\t\t\t\"author\": \"Richeve S. Bebedor\",\n\t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n\t\t\t\"contributors\": [\n\t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\",\n\t\t\t\t\"Vinse Vinalon <vinsevinalon@gmail.com>\"\n\t\t\t],\n\t\t\t\"repository\": \"https://github.com/volkovasystems/falzy.git\",\n\t\t\t\"test\": \"falzy-test.js\",\n\t\t\t\"global\": true\n\t\t}\n\t@end-module-configuration\n\n\t@module-documentation:\n\t\tCheck if the value is undefined, null, empty string, and NaN.\n\t@end-module-documentation\n\n\t@note:\n\t\tThis module should not have a dependency and should remain as simple as possible.\n\t@end-note\n*/\n\nconst falzy = function falzy( value ){\n\t/*;\n\t\t@meta-configuration:\n\t\t\t{\n\t\t\t\t\"value:required\": \"*\"\n\t\t\t}\n\t\t@end-meta-configuration\n\t*/\n\n\tif( typeof value == \"number\" ){\n\t\treturn isNaN( value );\n\t}\n\n\treturn ( typeof value == \"undefined\" || value === null || value === \"\" );\n};\n\nmodule.exports = falzy;\n\n\n\n// WEBPACK FOOTER //\n// falzy.support.js","\"use strict\";\n\n/*;\n\t@module-license:\n\t\tThe MIT License (MIT)\n\t\t@mit-license\n\n\t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n\t\t@email: richeve.bebedor@gmail.com\n\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\t\tof this software and associated documentation files (the \"Software\"), to deal\n\t\tin the Software without restriction, including without limitation the rights\n\t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t\tcopies of the Software, and to permit persons to whom the Software is\n\t\tfurnished to do so, subject to the following conditions:\n\n\t\tThe above copyright notice and this permission notice shall be included in all\n\t\tcopies or substantial portions of the Software.\n\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\t\tSOFTWARE.\n\t@end-module-license\n\n\t@module-configuration:\n\t\t{\n\t\t\t\"package\": \"truly\",\n\t\t\t\"path\": \"truly/truly.js\",\n\t\t\t\"file\": \"truly.js\",\n\t\t\t\"module\": \"truly\",\n\t\t\t\"author\": \"Richeve S. Bebedor\",\n\t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n\t\t\t\"contributors\": [\n\t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\",\n\t\t\t\t\"Vinse Vinalon <vinsevinalon@gmail.com>\"\n\t\t\t],\n\t\t\t\"repository\": \"https://github.com/volkovasystems/truly.git\",\n\t\t\t\"test\": \"truly-test.js\",\n\t\t\t\"global\": true\n\t\t}\n\t@end-module-configuration\n\n\t@module-documentation:\n\t\tCheck if the value is not undefined, null, empty string, NaN and Infinity.\n\t@end-module-documentation\n\n\t@note:\n\t\tThis module should not have a dependency and should remain as simple as possible.\n\t@end-note\n*/\n\nconst truly = function truly( value ){\n\t/*;\n\t\t@meta-configuration:\n\t\t\t{\n\t\t\t\t\"value:required\": \"*\"\n\t\t\t}\n\t\t@end-meta-configuration\n\t*/\n\n\tif( typeof value == \"number\" ){\n\t\treturn !isNaN( value );\n\t}\n\n\treturn ( typeof value != \"undefined\" && value !== null && value !== \"\" );\n};\n\nmodule.exports = truly;\n\n\n\n// WEBPACK FOOTER //\n// truly.support.js"],"sourceRoot":""}